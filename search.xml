<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>设计模式</title>
      <link href="/2022/08/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/08/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="六大原则"><a href="#六大原则" class="headerlink" title="六大原则"></a>六大原则</h2><table><thead><tr><th>名称</th><th>定义</th></tr></thead><tbody><tr><td>单一原则</td><td>原则一个类只提供一个方法，实际生产可破坏单一原则</td></tr><tr><td>开闭原则</td><td>对扩展开放，对修改关闭</td></tr><tr><td>依赖倒转</td><td>一个类最好有抽象类和实现接口，或者二者都有程序稳定，即面向接口编程</td></tr><tr><td>里式替换</td><td>子类尽量不要重写父类方法，所有使用基类的地方必须能透明使用其子类的对象</td></tr><tr><td>接口隔离</td><td>一个类对另一个类的依赖应该建立在最小的接口上</td></tr><tr><td>迪米特法则</td><td>只与直接的朋友通信（出现在成员变量方法参数，方法返回值的类），而出现在局部变量（方法）中的类不是直接朋友</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//里式替换</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">private</span> B b=<span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">    b.func1(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">func1</span><span class="params">(<span class="type">int</span> m,<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m+n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><h3 id="懒汉加载"><a href="#懒汉加载" class="headerlink" title="懒汉加载"></a>懒汉加载</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> single.huangry;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 祥哥</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * 1、恶汉加载之----静态常量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JingTaiChangLing</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">JingTaiChangLing</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">JingTaiChangLing</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JingTaiChangLing</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> JingTaiChangLing <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * single.huangry.JingTaiChangLing@39ae8a9b</span></span><br><span class="line"><span class="comment"> * single.huangry.JingTaiChangLing@39ae8a9b</span></span><br><span class="line"><span class="comment"> * single.huangry.JingTaiChangLing@39ae8a9b</span></span><br><span class="line"><span class="comment"> * single.huangry.JingTaiChangLing@39ae8a9b</span></span><br><span class="line"><span class="comment"> * single.huangry.JingTaiChangLing@39ae8a9b</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="type">JingTaiChangLing</span> <span class="variable">instance</span> <span class="operator">=</span> JingTaiChangLing.getInstance();</span><br><span class="line">                System.out.println(instance);</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> single.huangry;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 恶汉加载，可能造成内存浪费</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 祥哥</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * 2、恶汉加载之----静态代码块</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JingTaiDaiMaKuai</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">JingTaiDaiMaKuai</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> JingTaiDaiMaKuai instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> <span class="title class_">JingTaiDaiMaKuai</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> JingTaiDaiMaKuai <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * single.huangry.JingTaiDaiMaKuai@46a00ba1</span></span><br><span class="line"><span class="comment"> * single.huangry.JingTaiDaiMaKuai@46a00ba1</span></span><br><span class="line"><span class="comment"> * single.huangry.JingTaiDaiMaKuai@46a00ba1</span></span><br><span class="line"><span class="comment"> * single.huangry.JingTaiDaiMaKuai@46a00ba1</span></span><br><span class="line"><span class="comment"> * single.huangry.JingTaiDaiMaKuai@46a00ba1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="type">JingTaiDaiMaKuai</span> <span class="variable">instance</span> <span class="operator">=</span> JingTaiDaiMaKuai.getInstance();</span><br><span class="line">                System.out.println(instance);</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="懒汉加载-1"><a href="#懒汉加载-1" class="headerlink" title="懒汉加载"></a>懒汉加载</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> single.lazy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 祥哥</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * 3、懒汉式加载,----线程不安全</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NOThreadSafe</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">NOThreadSafe</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> NOThreadSafe instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> NOThreadSafe <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">NOThreadSafe</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *single.lazy.NOThreadSafe@d166de5</span></span><br><span class="line"><span class="comment"> * single.lazy.NOThreadSafe@6bfcab86</span></span><br><span class="line"><span class="comment"> * single.lazy.NOThreadSafe@d166de5</span></span><br><span class="line"><span class="comment"> * single.lazy.NOThreadSafe@1acc1ca0</span></span><br><span class="line"><span class="comment"> * single.lazy.NOThreadSafe@d166de5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="type">NOThreadSafe</span> <span class="variable">instance</span> <span class="operator">=</span> NOThreadSafe.getInstance();</span><br><span class="line">                System.out.println(instance);</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> single.lazy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程安全</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 祥哥</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * 4、懒汉加载之----双重检测锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadSafe</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">ThreadSafe</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> ThreadSafe instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ThreadSafe <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (ThreadSafe.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">ThreadSafe</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> single.lazy.ThreadSafe@72bb9f6e</span></span><br><span class="line"><span class="comment"> single.lazy.ThreadSafe@72bb9f6e</span></span><br><span class="line"><span class="comment"> single.lazy.ThreadSafe@72bb9f6e</span></span><br><span class="line"><span class="comment"> single.lazy.ThreadSafe@72bb9f6e</span></span><br><span class="line"><span class="comment"> single.lazy.ThreadSafe@72bb9f6e</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="type">ThreadSafe</span> <span class="variable">instance</span> <span class="operator">=</span> ThreadSafe.getInstance();</span><br><span class="line">                System.out.println(instance);</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> single.lazy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 祥哥</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> *5、懒汉式加载,静态内部类----线程安全</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JingTaiNeiBuLei</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">JingTaiNeiBuLei</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ObjectStatic</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">JingTaiNeiBuLei</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JingTaiNeiBuLei</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> JingTaiNeiBuLei <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ObjectStatic.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> single.lazy.JingTaiNeiBuLei@46a00ba1</span></span><br><span class="line"><span class="comment"> single.lazy.JingTaiNeiBuLei@46a00ba1</span></span><br><span class="line"><span class="comment"> single.lazy.JingTaiNeiBuLei@46a00ba1</span></span><br><span class="line"><span class="comment"> single.lazy.JingTaiNeiBuLei@46a00ba1</span></span><br><span class="line"><span class="comment"> single.lazy.JingTaiNeiBuLei@46a00ba1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test5</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="type">JingTaiNeiBuLei</span> <span class="variable">instance</span> <span class="operator">=</span> JingTaiNeiBuLei.getInstance();</span><br><span class="line">                System.out.println(instance);</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> single.toenum;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 祥哥</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * 6、枚举----线程安全</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">EnumSingle</span> &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 460141958</span></span><br><span class="line"><span class="comment"> * 460141958</span></span><br><span class="line"><span class="comment"> * 460141958</span></span><br><span class="line"><span class="comment"> * 460141958</span></span><br><span class="line"><span class="comment"> * 460141958</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test6</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="type">EnumSingle</span> <span class="variable">instance</span> <span class="operator">=</span> EnumSingle.INSTANCE;</span><br><span class="line">            System.out.println(instance.hashCode());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*简单工厂 ：用来生产同一等级结构中的任意产品。（不支持拓展增加产品）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">makeCar</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlueCar</span> <span class="keyword">implements</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeCar</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;制作一个Blue的车~~~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedCar</span> <span class="keyword">implements</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeCar</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;制作一个Red的车~~~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 简单工厂模式的代码相对于工厂方法模式的代码就是少了CarFactory工厂接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Car</span> <span class="variable">car1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedCar</span>();</span><br><span class="line">        <span class="type">Car</span> <span class="variable">car2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BlueCar</span>();</span><br><span class="line">        car1.makeCar();</span><br><span class="line">        car2.makeCar();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*工厂方法 ：用来生产同一等级结构中的固定产品。（支持拓展增加产品）</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">makeCar</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlueCar</span> <span class="keyword">implements</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeCar</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;制作一个Blue的车~~~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedCar</span> <span class="keyword">implements</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeCar</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;制作一个Red的车~~~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CarFactory</span> &#123;</span><br><span class="line">    Car <span class="title function_">makeCars</span><span class="params">(String type)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CarFactoryImpl</span> <span class="keyword">implements</span> <span class="title class_">CarFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Car <span class="title function_">makeCars</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        Car car;</span><br><span class="line">        <span class="keyword">if</span> (type.equals(<span class="string">&quot;red&quot;</span>)) &#123;</span><br><span class="line">            car = <span class="keyword">new</span> <span class="title class_">RedCar</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            car = <span class="keyword">new</span> <span class="title class_">BlueCar</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> car;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 可以一定程度上解耦，消费者和产品实现类隔离开，只依赖产品接口(抽象产品)，产品实现类如何改动与消费者完全无关。</span></span><br><span class="line"><span class="comment"> * 可以一定程度增加扩展性，若增加一个产品实现，只需要实现产品接口，修改工厂创建产品的方法，消费者可以无感知（若消费者不关心具体产品是什么的情况）。</span></span><br><span class="line"><span class="comment"> * 可以一定程度增加代码的封装性、可读性。清楚的代码结构，对于消费者来说很少的代码量就可以完成很多工作。</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MetTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//消费者只知道有一个汽车工厂</span></span><br><span class="line">        <span class="type">CarFactory</span> <span class="variable">carFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CarFactoryImpl</span>();</span><br><span class="line">        <span class="comment">//我需要一辆car</span></span><br><span class="line">        Car car;</span><br><span class="line">        <span class="comment">//我需要一辆什么颜色的car，具体car如何制作跟我消费者无任何关系，实现解耦</span></span><br><span class="line">        car = carFactory.makeCars(<span class="string">&quot;red&quot;</span>);</span><br><span class="line">        car.makeCar();</span><br><span class="line">        car = carFactory.makeCars(<span class="string">&quot;blue&quot;</span>);</span><br><span class="line">        car.makeCar();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*抽象工厂 ：用来生产不同产品族的全部产品。（不支持拓展增加产品；支持增加产品族）</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="comment">//汽车类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">makeCar</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlueCar</span> <span class="keyword">implements</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeCar</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;制作一个Blue的车~~~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedCar</span> <span class="keyword">implements</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeCar</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;制作一个Red的车~~~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//摩托车类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MotoCar</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">makeMotoCar</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlueMotoCar</span> <span class="keyword">implements</span> <span class="title class_">MotoCar</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeMotoCar</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;make Blue MotoCar&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedMotoCar</span> <span class="keyword">implements</span> <span class="title class_">MotoCar</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeMotoCar</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;make Red MotoCar&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//总工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    Car <span class="title function_">makeCar</span><span class="params">(String type)</span>;</span><br><span class="line">    MotoCar <span class="title function_">makeMotoCar</span><span class="params">(String type)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//汽车分工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CarFactory</span> <span class="keyword">implements</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Car <span class="title function_">makeCar</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        Car car;</span><br><span class="line">        <span class="keyword">if</span> (type.equals(<span class="string">&quot;red&quot;</span>)) &#123;</span><br><span class="line">            car = <span class="keyword">new</span> <span class="title class_">RedCar</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            car = <span class="keyword">new</span> <span class="title class_">BlueCar</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> car;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> MotoCar <span class="title function_">makeMotoCar</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//摩托分工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MotoCarFactory</span> <span class="keyword">implements</span> <span class="title class_">Factory</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Car <span class="title function_">makeCar</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> MotoCar <span class="title function_">makeMotoCar</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        MotoCar motoCar;</span><br><span class="line">        <span class="keyword">if</span>(type.equals(<span class="string">&quot;red&quot;</span>))&#123;</span><br><span class="line">            motoCar = <span class="keyword">new</span> <span class="title class_">RedMotoCar</span>();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            motoCar = <span class="keyword">new</span> <span class="title class_">BlueMotoCar</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> motoCar;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FactoryProduct</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Factory <span class="title function_">getFactory</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        Factory factory;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;car&quot;</span>.equals(type)) &#123;</span><br><span class="line">            factory = <span class="keyword">new</span> <span class="title class_">CarFactory</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            factory = <span class="keyword">new</span> <span class="title class_">MotoCarFactory</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> factory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。</span></span><br><span class="line"><span class="comment"> * 该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，</span></span><br><span class="line"><span class="comment"> * 它提供了一种创建对象的最佳方式。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbsCar</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//消费者只知道有一个汽车工厂的产品，可以在汽车工厂产品里获取生产对应汽车的工厂</span></span><br><span class="line">        <span class="type">Factory</span> <span class="variable">factory</span> <span class="operator">=</span> FactoryProduct.getFactory(<span class="string">&quot;car&quot;</span>);</span><br><span class="line">        <span class="comment">//汽车工厂获取红色汽车</span></span><br><span class="line">        <span class="type">Car</span> <span class="variable">car</span> <span class="operator">=</span> factory.makeCar(<span class="string">&quot;red&quot;</span>);</span><br><span class="line">        car.makeCar();</span><br><span class="line">        <span class="comment">//从汽车工厂产品里获取摩托车工厂</span></span><br><span class="line">        <span class="type">Factory</span> <span class="variable">factory1</span> <span class="operator">=</span> FactoryProduct.getFactory(<span class="string">&quot;motocar&quot;</span>);</span><br><span class="line">        <span class="comment">//摩托车工厂获取蓝色摩托车</span></span><br><span class="line">        <span class="type">MotoCar</span> <span class="variable">motoCar</span> <span class="operator">=</span> factory1.makeMotoCar(<span class="string">&quot;blue&quot;</span>);</span><br><span class="line">        motoCar.makeMotoCar();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络</title>
      <link href="/2022/07/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
      <url>/2022/07/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="OSI七层"><a href="#OSI七层" class="headerlink" title="OSI七层"></a>OSI七层</h2><h3 id="OSI七层模型从上到下依次为："><a href="#OSI七层模型从上到下依次为：" class="headerlink" title="OSI七层模型从上到下依次为："></a>OSI七层模型从上到下依次为：</h3><p>应用层：为应用程序提供网络服务。</p><p>表示层：数据格式转换、数据压缩和数据加密。</p><p>会话层：建立、断开和维护通信链接。</p><p>传输层：为上层协议提供端到端的可靠传输。</p><p>网络层：寻址和路由。</p><p>数据链路层：定义通过通信媒介互连的设备之间传输的规范。</p><p>物理层：利用物理传输介质为数据链路层提供物理连接。</p><p>TCP五层模型相比OSI七层模型，将OSI的应用层、表示层和会话层合为一层：应用层，其他不变。</p><p><img src="https://cdn.jsdelivr.net/gh/XueZhengXiang/photo/img/%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B.png"></p><h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p><img src="https://cdn.jsdelivr.net/gh/XueZhengXiang/photo/img/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E6%A0%87.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/XueZhengXiang/photo/img/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B1.jpg"></p><h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><p><img src="https://cdn.jsdelivr.net/gh/XueZhengXiang/photo/img/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png"></p><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><h3 id="TCP-协议如何保证可靠传输"><a href="#TCP-协议如何保证可靠传输" class="headerlink" title="TCP 协议如何保证可靠传输"></a>TCP 协议如何保证可靠传输</h3><ul><li>停止等待：每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</li><li>超时重传：当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段；</li><li>流量控制：TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。TCP使用的流量控制协议是可变大小的滑动窗口协议。</li><li>拥塞控制： 当网络拥塞时，可能会造成网络的拥堵，甚至网络瘫痪，TCP会减少数据的发送。</li><li>数据包校验：TCP 将保持它首部和数据的检验和，这是一个端到端的检验和。目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时TCP发送数据端超时后会重发数据；</li><li>对失序数据包重排序：既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序。TCP给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。</li><li>应答机制：当TCP收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒；<br>丢弃重复数据：TCP 的接收端会丢弃重复的数据。</li></ul><h3 id="TCP拥塞控制？"><a href="#TCP拥塞控制？" class="headerlink" title="TCP拥塞控制？"></a>TCP拥塞控制？</h3><p><strong>拥塞控制是防止过多的数据注入网络，使得网络中的路由器或者链路过载。流量控制是点对点的通信量控制，而拥塞控制是全局的网络流量整体性的控制。发送双方都有一个拥塞窗口（cwnd）。</strong></p><ul><li>慢开始：最开始发送方的拥塞窗口为1，由小到大递增。每经过一个传输轮次，拥塞窗口cwnd加倍（乘2）。当cwnd超过慢开始门限，则使用拥塞避免算法，避免cwnd增长过长。</li><li>拥塞避免（算法）：当cwnd超过慢开始门限，每经过一个往返时间RTT，cwnd就增长1。在慢开始和拥塞避免过程中，一旦发现网络拥塞，就把慢开始门限设置为当前值的一半，并且重新设置cwnd为1，重新慢启动。</li><li>快重传：接收方每收到一个失序的报文段后就立即发出重复确认，发送方只要收到3个重复确认就立即重传。</li><li>快恢复：当发送方连续收到三个重复确认，就将慢开始门限减半，将当前的窗口设置为慢开始门限，并采用拥塞避免算法。（采用快恢复算法时，慢开始只在建立连接和网络超时时才使用）</li></ul><h2 id="HTTP与HTTPS"><a href="#HTTP与HTTPS" class="headerlink" title="HTTP与HTTPS"></a>HTTP与HTTPS</h2><p><strong>HTTP是一个基于TCP&#x2F;IP通信协议来传递数据的协议。HTTP协议工作于客户端-服务端架构之上，实现可靠性的传输文字、图片、音频、视频等超文本数据的规范，格式简称为“超文本传输协议”。Http协议属于应用层，用户访问的第一层就是http。</strong></p><p>特点：</p><p>①简单快速：客户端向服务器发送请求时，只需传送请求方法和路径即可。<br>②灵活：HTTP允许传输任意类型的数据对象。<br>③无连接：限制每次连接只处理一个请求。服务器处理完客户请求，并收到客户应答后，即断开连接。<br>④无状态：协议对于事务处理没有记忆能力。<br>⑤支持B&#x2F;S及C&#x2F;S模式。</p><h2 id="Http和Https的区别？"><a href="#Http和Https的区别？" class="headerlink" title="Http和Https的区别？"></a>Http和Https的区别？</h2><p>端口不同：Http是80，Https443<br>安全性：http是超文本传输协议，信息是明文传输，https则是通过SSL加密处理的传输协议，更加安全。<br>是否付费：https需要拿到CA证书，需要付费<br>连接方式：http和https使用的是完全不同的连接方式（HTTP的连接很简单，是无状态的；HTTPS 协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。）</p><p>HTTPS传输过程中使用密钥加密，安全性更高。但是收费，而且多了一层SSL延时也会有所提高。</p><h3 id="HTTPS工作原理"><a href="#HTTPS工作原理" class="headerlink" title="HTTPS工作原理"></a>HTTPS工作原理</h3><ul><li>首先HTTP请求服务端生成证书，客户端对证书的有效期、合法性、域名是否与请求的域名一致、证书的公钥（RSA加密）等进行校验。</li><li>客户端如果校验通过后，就根据证书的公钥的有效， 生成随机数，随机数使用公钥进行加密（RSA加密）。</li><li>消息体产生的后，对它的摘要进行MD5（或者SHA1）算法加密，此时就得到了RSA签名。</li><li>发送给服务端，此时只有服务端（RSA私钥）能解密。</li><li>解密得到的随机数，再用AES加密，作为密钥（此时的密钥只有客户端和服务端知道）。</li></ul><h3 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h3><p><strong>加密算法：对信息进行编码和解码的技术，编码是把原来可读信息（又称明文）译成代码形式（又称密文），其逆过程就是解码（解密）。</strong></p><p>加密技术的要点是加密算法，加密算法可以分为三类：</p><ol><li><strong>对称加密，如 AES</strong><br>基本原理：将明文分成 N 个组，然后使用密钥对各个组进行加密，形成各自的密文，最后把所有的分组密文进行合并，形成最终的密文。<br>优点：算法公开、计算量小、加密速度快、加密效率高<br>缺点：双方都使用同样密钥，安全性得不到保证</li><li><strong>非对称加密，如 RSA</strong><br>基本原理：同时生成两把密钥：私钥和公钥，私钥隐秘保存，公钥可以下发给信任客户端<br>私钥加密，持有私钥或公钥才可以解密<br>公钥加密，持有私钥才可解密<br>优点：安全，难以破解<br>缺点：算法比较耗时</li><li><strong>不可逆加密，如 MD5，SHA</strong><br>基本原理：加密过程中不需要使用密钥，输入明文后由系统直接经过加密算法处理成密文，这种加密后的数据是无法被解密的，无法根据密文推算出明文。</li></ol><h3 id="一次完整的HTTP请求所经历几个步骤"><a href="#一次完整的HTTP请求所经历几个步骤" class="headerlink" title="一次完整的HTTP请求所经历几个步骤?"></a>一次完整的HTTP请求所经历几个步骤?</h3><p><strong>HTTP协议采用请求&#x2F;响应模型。客户端向服务器发送一个请求报文，请求报文包含请求方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应内容包括协议版本、成功或者错误的代码、服务器信息、响应头部和响应数据。</strong></p><p><strong>Web浏览器与Web服务器之间将完成下列7个步骤：</strong></p><ol><li><p>建立TCP连接，三次握手。</p></li><li><p>Web浏览器向Web服务器发送请求行。</p></li><li><p>Web浏览器发送请求头，浏览器发送其请求命令之后，还要以头信息的形式向Web服务器发送一些别的信息，之后浏览器发送了一空白行来通知服务器，它已经结束了该头信息的发送。</p></li><li><p>Web服务器应答：客户机向服务器发出请求后，服务器会客户机回送应答， HTTP&#x2F;1.1 200 OK ，应答的第一部分是协议的版本号和应答状态码。</p></li><li><p>Web服务器发送应答头：正如客户端会随同请求发送关于自身的信息一样，服务器也会随同应答向用户发送关于它自己的数据及被请求的文档。</p></li><li><p>Web服务器向浏览器发送数据：Web服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它就以Content-Type应答头信息所描述的格式发送用户所请求的实际数据。</p></li><li><p>Web服务器关闭TCP连接。</p></li></ol><h3 id="什么是http的请求体？"><a href="#什么是http的请求体？" class="headerlink" title="什么是http的请求体？"></a>什么是http的请求体？</h3><h4 id="HTTP请求体"><a href="#HTTP请求体" class="headerlink" title="HTTP请求体"></a>HTTP请求体</h4><p><strong>请求行 、请求头、请求数据组成的。</strong></p><h4 id="http的响应报文"><a href="#http的响应报文" class="headerlink" title="http的响应报文"></a>http的响应报文</h4><p> <strong>状态行、响应首部字段、响应内容实体</strong></p><h3 id="输入网址到获取页面的过程？"><a href="#输入网址到获取页面的过程？" class="headerlink" title="输入网址到获取页面的过程？"></a>输入网址到获取页面的过程？</h3><p>浏览器搜索自身的DNS缓存、搜索操作系统的DNS缓存、读取本地的Host文件和向本地DNS服务器进行查询等。<br>对于向本地DNS服务器进行查询，如果要查询的域名包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析(此解析具有权威性)；如果要查询的域名不由本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析（此解析不具有权威性）。如果本地域名服务器并未缓存该网址映射关系，那么将根据其设置发起递归查询或者迭代查询；<br>浏览器获得域名对应的IP地址以后，浏览器向服务器请求建立链接，发起三次握手；<br>TCP&#x2F;IP链接建立起来后，浏览器向服务器发送HTTP请求；<br>服务器接收到这个请求，并根据路径参数映射到特定的请求处理器进行处理，并将处理结果及相应的视图返回给浏览器；<br>浏览器解析并渲染视图，若遇到对js文件、css文件及图片等静态资源的引用，则重复上述步骤并向服务器请求这些资源；<br>浏览器根据其请求到的资源、数据渲染页面，最终向用户呈现一个完整的页面。</p><h3 id="http版本的对比"><a href="#http版本的对比" class="headerlink" title="http版本的对比"></a>http版本的对比</h3><h4 id="HTTP1-0版本的特性："><a href="#HTTP1-0版本的特性：" class="headerlink" title="HTTP1.0版本的特性："></a>HTTP1.0版本的特性：</h4><p><strong>早先1.0的HTTP版本，是一种无状态、无连接的应用层协议。（短连接）</strong><br>HTTP1.0规定浏览器和服务器保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器处理完成后立即断开TCP连接（无连接），服务器不跟踪每个客户端也不记录过去的请求（无状态）。</p><p><strong>HTTP1.1版本新特性（长连接）</strong>：<br>默认持久连接节省通信量，只要客户端服务端任意一端没有明确提出断开TCP连接，就一直保持连接，可以发送多次HTTP请求管线化，客户端可以同时发出多个HTTP请求，而不用一个个等待响应断点续传原理</p><h4 id="HTTP2-0版本的特性："><a href="#HTTP2-0版本的特性：" class="headerlink" title="HTTP2.0版本的特性："></a>HTTP2.0版本的特性：</h4><ol><li>二进制分帧（采用二进制格式的编码将其封装）</li><li>首部压缩（设置了专门的首部压缩设计的HPACK算法。）</li><li>流量控制（设置了接收某个数据流的多少字节一些流量控制）</li><li>多路复用（可以在共享TCP链接的基础上同时发送请求和响应）</li><li>请求优先级（可以通过优化这些帧的交错和传输顺序进一步优化性能）</li><li>服务器推送（就是服务器可以对一个客户端请求发送多个响应。服务器向客户端推送资源无需客户端明确的请求。（重大更新）</li></ol><h4 id="常用HTTP状态码是怎么分类的，有哪些常见的状态码？"><a href="#常用HTTP状态码是怎么分类的，有哪些常见的状态码？" class="headerlink" title="常用HTTP状态码是怎么分类的，有哪些常见的状态码？"></a>常用HTTP状态码是怎么分类的，有哪些常见的状态码？</h4><p>HTTP状态码表示客户端HTTP请求的返回结果、标识服务器处理是否正常、表明请求出现的错误等。状态码的类别：<br>在这里插入图片描述</p><pre><code>常用状态码：200： 请求被正常处理204： 请求被受理但没有资源可以返回301： 永久性重定向302： 临时重定向304： 已缓存400： 请求报文语法有误，服务器无法识别403： 请求的对应资源禁止被访问404： 服务器无法找到对应资源500： 服务器内部错误503： 服务器正忙</code></pre><h3 id="HTTP协议中的请求方式"><a href="#HTTP协议中的请求方式" class="headerlink" title="HTTP协议中的请求方式"></a>HTTP协议中的请求方式</h3><pre><code>GET：用于请求访问已经被URI（统一资源标识符）识别的资源，可以通过URL传参给服务器POST：用于传输信息给服务器，主要功能与GET方法类似，但一般推荐使用POST方式。PUT： 传输文件，报文主体中包含文件内容，保存到对应URI位置。HEAD：获得报文首部，与GET方法类似，只是不返回报文主体，一般用于验证URI是否有效。PATCH： 客户端向服务器传送的数据取代指定的文档的内容(部分取代)TRACE： 回显客户端请求服务器的原始请求报文，用于&quot;回环&quot;诊断DELETE： 删除文件，与PUT方法相反，删除对应URI位置的文件。OPTIONS： 查询相应URI支持的HTTP方法。</code></pre><h3 id="GET方法与POST方法的区别"><a href="#GET方法与POST方法的区别" class="headerlink" title="GET方法与POST方法的区别"></a>GET方法与POST方法的区别</h3><ul><li>功能上： GET一般用来从服务器上获取资源，POST一般用来更新服务器上的资源；</li><li>安全性： GET是不安全的，因为GET请求提交的数据将明文出现在URL上（请求头上），可能会泄露私密信息；POST请求参数则被包装到请求体中，相对更安全。</li><li>数据量： Get传输的数据量小，因为受URL长度限制，但效率较高； Post可以传输大量数据，所以上传文件时只能用Post方式；</li></ul><h2 id="Session-与-Cookie-的对比"><a href="#Session-与-Cookie-的对比" class="headerlink" title="Session 与 Cookie 的对比"></a>Session 与 Cookie 的对比</h2><p>cookie：cookie是由Web服务器保存在用户浏览器上的文件（key-value格式），可以包含用户相关的信息。客户端向服务器发起请求时，会携带服务器端之前创建的cookie，服务器端通过cookie中携带的数据区分不同的用户。</p><p>session：session 是浏览器和服务器会话过程中，服务器会分配的一块储存空间给session。服务器默认会为客户浏览器的cookie中设置 sessionid，这个sessionid就和cookie对应，浏览器在向服务器请求过程中传输的cookie 包含 sessionid ，服务器根据传输cookie 中的 sessionid 获取出会话中存储的信息，然后确定会话的身份信息。</p><ol><li>安全性：cookie数据存放在客户端上，安全性较差，session数据放在服务器上，安全性相对更高。</li><li>大小限制：cookie有大小限制，单个cookie保存的数据不能超过4K，session无此限制，理论上只与服务器的内存大小有关。</li><li>服务器资源消耗：Session是保存在服务器端上会存在一段时间才会消失，当访问增多，对服务器性能有影响。</li><li>实现机制：Session的实现常常依赖于Cookie机制，通过Cookie机制回传SessionID。</li></ol><p><strong>HTTP协议本身是无法判断用户身份。所以需要cookie或者session</strong>。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JVM</title>
      <link href="/2022/06/29/JVM/"/>
      <url>/2022/06/29/JVM/</url>
      
        <content type="html"><![CDATA[<h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><p>Java 虚拟机是一台执行 Java 字节码的虚拟计算机，它拥有独立的运行机制，其运行的 Java 字节码也未必由 Java 语言编译而成。</p><p>JVM 平台的各种语言可以共享 Java 虚拟机带来的跨平台性、优秀的垃圾回器，以及可靠的即时编译器。</p><p>Java 技术的核心就是 Java 虚拟机（JVM，Java Virtual Machine），因为所有的 Java程序都运行在 Java 虚拟机内部。</p><p>Java 虚拟机就是二进制字节码的运行环境，负责装载字节码到其内部，解释&#x2F;编译为对应平台上的机器指令执行。每一条 Java 指令，Java 虚拟机规范中都有详细定义，如怎么取操作数，怎么处理操作数，处理结果放在哪里。</p><p><strong>特点</strong>：</p><ul><li>一次编译，到处运行 </li><li>自动内存管理</li><li>自动垃圾回收功能</li></ul><p><strong>位置</strong>：操作系统之上，它与硬件没有直接的交互。</p><p><img src="https://cdn.jsdelivr.net/gh/XueZhengXiang/photo/img/JVM.png"></p><h2 id="JVM组成"><a href="#JVM组成" class="headerlink" title="JVM组成"></a>JVM组成</h2><h3 id="类加载子系统"><a href="#类加载子系统" class="headerlink" title="类加载子系统"></a>类加载子系统</h3><p>根据给定的全限定名类名(如：java.lang.Object)来装载class文件到运行时数据区中的方法区；</p><p><strong>加载</strong></p><p>通过一个类的全限定名获取定义此类的二进制字节流，将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构；</p><p>在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">启动类加载器 （BootStrap ClassLoader） –是虚拟机自身的一部分，C++实现，负责从 bootstrap classpath 中加载类（J&lt;JAVA_HOME&gt;\jre\lib\目录中的，或者被 -Xbootclasspath 参数所指定的路径中并且被虚拟机识别的类库），有且只有一个 rt.jar 文件，该加载器具有最高优先级；</span><br><span class="line">扩展加载器（Extension ClassLoader） – 它是Java实现的，独立于虚拟机，主要负责加载&lt;JAVA_HOME&gt;\jre\lib\ext\目录中或被java.ext.dirs系统变量所指定的路径的类库；</span><br><span class="line">应用加载器（Application ClassLoader）– 它是Java实现的，独立于虚拟机，负责从用户定义的 classpath 中加载类，用户可以通过指定环境变量的方式定义该目录，如： java -classpath。一般情况下，如果没有自定义类加载器默认就是用这个加载器。</span><br></pre></td></tr></table></figure><p>以上类加载器通过<strong>双亲委派</strong>模型执行类加载。<br><strong>链接</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">校验（Verify） – 字节码验证器会验证生成的字节码是否正确，如果校验失败，会返回校验错误。</span><br><span class="line">准备（Prepare） – 所有的静态变量会被分配内存。</span><br><span class="line">解析（Resolve） – 虚拟机将常量池中的符号引用替换为直接引用的过程。符号引用可以理解为一个标示，而直接引用是直接指向内存中的地址。</span><br></pre></td></tr></table></figure><p><strong>初始化</strong></p><p>初始化是类加载的最后一步，对静态变量和静态代码块执行初始化工作。在这里静态变量会被赋予初值，静态方法区会被执行。</p><h3 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h3><p>当我们通过前面的：类的加载-&gt; 验证 -&gt; 准备 -&gt; 解析 -&gt; 初始化 这几个阶段完成后，就会用到执行引擎对我们的类进行使用，同时执行引擎将会使用到我们运行时数据区。</p><h4 id="划分JDK8"><a href="#划分JDK8" class="headerlink" title="划分JDK8"></a>划分JDK8</h4><table><thead><tr><th>名称</th><th>线程共享</th><th>作用</th><th>内部结构</th><th>是否会OOM</th></tr></thead><tbody><tr><td>程序计数器</td><td>线程私有</td><td>存储指向下一条指令的地址，由执行引擎读取</td><td>JVM 中的 PC 寄存器是对物理 PC 寄存器的一种抽象模拟。</td><td>不会</td></tr><tr><td>本地方法栈</td><td>线程私有</td><td>管理本地方法的执行</td><td>Hotspot JVM 中，直接将本地方法栈和虚拟机栈合二为一。</td><td>会</td></tr><tr><td>虚拟机栈</td><td>线程私有</td><td>主管 Java 程序的运行，保存方法的局部变量、部分结果，并参与方法的调用和返回</td><td>栈帧（局部变量表、操作数栈、动态链接、方法返回地址，附加信息）</td><td>会</td></tr><tr><td>堆</td><td>线程共享</td><td>存放所有new出来的对象</td><td>新生区（Eden:8+S1:1+S2:1):1+老年区:2</td><td>会</td></tr><tr><td>元空间（方法区）</td><td>线程共享</td><td>主要存放的是 Class</td><td>无永久代，类型信息、字段、方法、常量保存在本地内存的元空间，但字符串常量池、静态变量仍然在堆中。</td><td>会</td></tr></tbody></table><h4 id="对象内存布局"><a href="#对象内存布局" class="headerlink" title="对象内存布局"></a>对象内存布局</h4><ol><li><strong>Mark Word</strong></li><li><strong>类型指针</strong></li><li><strong>数组长度（只有数组对象有）</strong></li></ol><h3 id="执行引擎"><a href="#执行引擎" class="headerlink" title="执行引擎"></a>执行引擎</h3><p>执行引擎属于 JVM 的下层，里面包括：</p><ul><li>解释器：当 Java 虚拟机启动时会根据预定义的规范对字节码采用逐行解释的方式执行，将每条字节码文件中的内容“翻译”为对应平台的本地机器指令执行。</li><li>及时编译器：就是虚拟机将源代码直接编译成和本地机器平台相关的机器语言。</li><li>垃圾回收器</li></ul><p><strong>作用：</strong>如果想要让一个 Java 程序运行起来，执行引擎（Execution Engine）的任务就是将字节码指令解释&#x2F;编译为对应平台上的本地机器指令才可以。</p><p><strong>执行引擎工作流程</strong></p><ol><li>执行引擎在执行的过程中究竟需要执行什么样的字节码指令完全依赖于 PC 寄存器。</li><li>每当执行完一项指令操作后，PC 寄存器就会更新下一条需要被执行的指令地址。</li><li>当然方法在执行的过程中，执行引擎有可能会通过存储在局部变量表中的对象引用准确定位到存储在 Java 堆区中的对象实例信息，以及通过对象头中的元数据指针定位到目标对象的类型信息。</li></ol><h3 id="本地接口"><a href="#本地接口" class="headerlink" title="本地接口"></a>本地接口</h3><p>一个Native Method就是一个java调用一个非java方法的接口。</p><ul><li>调用非java代码，需要与java外面的环境进行交互。</li><li>与操作系统的交互。</li></ul><h2 id="java垃圾回收机制"><a href="#java垃圾回收机制" class="headerlink" title="java垃圾回收机制"></a>java垃圾回收机制</h2><p><strong>优点</strong></p><ol><li>自动内存管理，无需开发人员手动参与内存的分配与回收，这样降低内存泄漏和内存溢出的风险。</li><li>没有垃圾回收器，java 也会和 cpp 一样，各种悬垂指针，野指针，泄露问题让你头疼不已。</li><li>自动内存管理机制，将程序员从繁重的内存管理中释放出来，可以更专心地专注于业务开发。</li></ol><h3 id="垃圾回收过程"><a href="#垃圾回收过程" class="headerlink" title="垃圾回收过程"></a><strong>垃圾回收过程</strong></h3><h4 id="标记阶段"><a href="#标记阶段" class="headerlink" title="标记阶段"></a>标记阶段</h4><p><strong>引用计数算法</strong>：会有循环引用关系问题。</p><p><strong>可达性分析算法</strong></p><p><strong>基本思路</strong>：</p><ul><li>可达性分析算法是以根对象集合（GCRoots）为起始点，按照从上至下的方式搜索被根对象集合所连接的目标对象是否可达。</li><li>使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为引用链（Reference Chain） 。</li><li>如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象己经死亡，可以标记为垃圾对象。</li><li>在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象。</li></ul><p><strong>GC Roots</strong> <strong>可以是哪些？</strong></p><ul><li>虚拟机栈中引用的对象。比如：各个线程被调用的方法中使用到的参数、局部变量等。</li><li>本地方法栈内 JNI（通常说的本地方法）引用的对象方法区中类静态属性引用的对象。比如：Java 类的引用类型静态变量。</li><li>方法区中常量引用的对象。比如：字符串常量池（string Table）里的引用。</li><li>所有被同步锁 synchronized 持有的对象。</li><li>Java 虚拟机内部的引用。基本数据类型对应的 Class 对象，一些常驻的异常对象（如：Nu11PointerException、outofMemoryError），系统类加载器。</li><li>反映 java 虚拟机内部情况的 JMXBean、JVMTI 中注册的回调、本地代码缓存等。</li></ul><h3 id="清除阶段"><a href="#清除阶段" class="headerlink" title="清除阶段"></a>清除阶段</h3><p>当成功区分出内存中存活对象和死亡对象后，GC 接下来的任务就是执行垃圾回收，释放掉无用对象所占用的内存空间，以便有足够的可用内存空间为新对象分配内存。</p><p>目前在 JVM 中比较常见的三种垃圾收集算法：</p><ul><li>标记一清除算法（Mark-Sweep） </li><li>复制算法（copying） </li><li>标记-整理算法（Mark-Compact）</li></ul><table><thead><tr><th>名称</th><th>速度</th><th>空间开销</th><th>移动对象</th></tr></thead><tbody><tr><td>标记清除</td><td>中等</td><td>少(会堆积碎片)</td><td>否</td></tr><tr><td>复制</td><td>最快</td><td>通常是活对象2倍空间(不堆积碎片)</td><td>是</td></tr><tr><td>标记整理</td><td>最慢</td><td>少(不会堆积碎片)</td><td>是</td></tr></tbody></table><h2 id="垃圾回收概念"><a href="#垃圾回收概念" class="headerlink" title="垃圾回收概念"></a>垃圾回收概念</h2><h3 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a><strong>内存溢出</strong></h3><p>内存溢出相对于内存泄漏来说，尽管更容易被理解，但是同样的，内存溢出也是引发程序崩溃的罪魁祸首之一。由于 GC 一直在发展，所有一般情况下，除非应用程序占用的内存增长速度非常快，造成垃圾回收已经跟不上内存消耗的速度，否则不太容易出现 ooM 的情况。</p><p>大多数情况下，GC 会进行各种年龄段的垃圾回收，实在不行了就放大招，来一次独占式的 Fu11GC 操作，这时候会回收大量的内存，供应用程序继续使用。javadoc 中对 outofMemoryError 的解释是，没有空闲内存，并且垃圾收集器也无法提供更多内存。</p><p>首先说没有空闲内存的情况：说明 Java 虚拟机的堆内存不够。原因有二：</p><ol><li>Java 虚拟机的堆内存设置不够。比如：可能存在内存泄漏问题；也很有可能就是堆的大小不合理，比如我们要处理比较可观的数据量，但是没有显式指定 JVM 堆大小或者指定数值偏小。我们可以通过参数-Xms 、-Xmx 来调整。</li><li>代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）对于老版本的 oracle JDK，因为永久代的大小是有限的，并且 JVM 对永久代垃圾回收（如，常量池回收、卸载不再需要的类型）非常不积极，所以当我们不断添加新类型的时候，永久代出现 OutOfMemoryError 也非常多见，尤其是在运行时存在大量动态类型生成的场合；类似 intern 字符串缓存占用太多空间，也会导致 OOM 问题。对应的异常信息，会标记出来和永久代相关：“java.lang.OutOfMemoryError:PermGen space”。随着元数据区的引入，方法区内存已经不再那么窘迫，所以相应的 ooM 有所改观，出现 ooM，异常信息则变了：“java.lang.OutofMemoryError:Metaspace”。直接内存不足，也会导致 OOM。这里面隐含着一层意思是，在抛出 OutofMemoryError 之前，通常垃圾收集器会被触发，尽其所能去清理出空间。例如：在引用机制分析中，涉及到 JVM 会去尝试回收软引用指向的对象等。 在java.nio.BIts.reserveMemory（）方法中，我们能清楚的看到，System.gc（）会被调用，以清理空间。当然，也不是在任何情况下垃圾收集器都会被触发的比如，我们去分配一个超大对象，类似一个超大数组超过堆的最大值，JVM 可以判断出垃圾收集并不能解决这个问题，所以直接抛出 OutofMemoryError。</li></ol><h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a><strong>内存泄漏</strong></h3><p>也称作“存储渗漏”。严格来说，只有对象不会再被程序用到了，但是 GC 又不能回收他们的情况，才叫内存泄漏。但实际情况很多时候一些不太好的实践（或疏忽）会导致对象的生命周期变得很长甚至导致 00M，也可以叫做宽泛意义上的“内存泄漏”。尽管内存泄漏并不会立刻引起程序崩溃，但是一旦发生内存泄漏，程序中的可用内存就会被逐步蚕食，直至耗尽所有内存，最终出现 outofMemory 异常，导致程序崩溃。</p><p>注意，这里的存储空间并不是指物理内存，而是指虚拟内存大小，这个虚拟内存大小取决于磁盘交换区设定的大小。买房子：80 平的房子，但是有 10 平是公摊的面积，我们是无法使用这 10 平的空间，这就是所谓的内存泄漏。Java 使用可达性分析算法，最上面的数据不可达，就是需要被回收的。后期有一些对象不用了，按道理应该断开引用，但是存在一些链没有断开，从而导致没有办法被回收。</p><p><strong>举例</strong></p><ul><li>单例模式</li></ul><p>单例的生命周期和应用程序是一样长的，所以单例程序中，如果持有对外部对象的引用的话，那么这个外部对象是不能被回收的，则会导致内存泄漏的产生。</p><ul><li>一些提供 close 的资源未关闭导致内存泄漏</li></ul><p>数据库连接（dataSourse.getConnection() ），网络连接（socket）和 io 连接必须手动 close，否则是不能被回收的。</p><h3 id="Stop-The-World"><a href="#Stop-The-World" class="headerlink" title="Stop The World"></a><strong>Stop The World</strong></h3><p>stop-the-world，简称 STw，指的是 GC 事件发生过程中，会产生应用程序的停顿。停顿产生时整个应用程序线程都会被暂停，没有任何响应，有点像卡死的感觉，这个停顿称为 STW。可达性分析算法中枚举根节点（GC Roots）会导致所有 Java 执行线程停顿。</p><ul><li>分析工作必须在一个能确保一致性的快照中进行</li><li>一致性指整个分析期间整个执行系统看起来像被冻结在某个时间点上</li><li>如果出现分析过程中对象引用关系还在不断变化，则分析结果的准确性无法保证 被 STW 中断的应用程序线程会在完成 GC 之后恢复，频繁中断会让用户感觉像是网速不快造成电影卡带一样，所以我们需要减少 STw 的发生。STW 事件和采用哪款 GC 无关所有的 GC 都有这个事件。哪怕是 G1 也不能完全避免 Stop-the-world 情况发生，只能说垃圾回收器越来越优秀，回收效率越来越高，尽可能地缩短了暂停时间。STW 是 JVM 在后台自动发起和自动完成的。在用户不可见的情况下，把用户正常的工作线程全部停掉。开发中不要用 system.gc() 会导致 stop-the-world 的发生。</li></ul><h3 id="垃圾回收的并行与并发"><a href="#垃圾回收的并行与并发" class="headerlink" title="垃圾回收的并行与并发"></a><strong>垃圾回收的并行与并发</strong></h3><p><strong>并发</strong></p><p>在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理器上运行。并发不是真正意义上的“同时进行”，只是 CPU 把一个时间段划分成几个时间片段（时间区间），然后在这几个时间区间之间来回切换，由于 CPU 处理的速度非常快，只要时间间隔处理得当，即可让用户感觉是多个应用程序同时在进行。</p><p><strong>并行</strong></p><p>当系统有一个以上 CPU 时，当一个 CPU 执行一个进程时，另一个 CPU 可以执行另一个进程，两个进程互不抢占 CPU 资源，可以同时进行，我们称之为并行（Paralle1）。其实决定并行的因素不是 CPU 的数量，而是 CPU 的核心数量，比如一个 CPU 多个核也可以并行。</p><p>适合科学计算，后台处理等弱交互场景</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li>强引用（StrongReference）：最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“object obj&#x3D;new Object（）”这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。 </li><li>软引用（SoftReference）：在系统将要发生内存溢出之前，将会把这些对象列入回收范围之中进行第二次回收。如果这次回收后还没有足够的内存，才会抛出内存流出异常。</li><li>弱引用（WeakReference）：被弱引用关联的对象只能生存到下一次垃圾收集之前。当垃圾收集器工作时，无论内存空间是否足够，都会回收掉被弱引用关联的对象。</li><li>虚引用（PhantomReference）：一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获得一个对象的实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</li></ul><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><table><thead><tr><th>垃圾收集器</th><th>分类</th><th>作用位置</th><th>算法</th><th>特点</th><th>适合场景</th></tr></thead><tbody><tr><td>Serial</td><td>串行</td><td>新生代</td><td>复制</td><td>响应速度优先</td><td>单CPU下的client模式</td></tr><tr><td>ParNew</td><td>并行</td><td>新生代</td><td>复制</td><td>响应速度优先</td><td>多CPU的server模式与CMS配合</td></tr><tr><td>Parallel</td><td>并行</td><td>新生代</td><td>复制</td><td>吞吐量优先</td><td>后台运算不需要太多交互</td></tr><tr><td>Serial Old</td><td>串行</td><td>老年代</td><td>标记-整理</td><td>响应速度优先</td><td>单CPU下的client模式</td></tr><tr><td>Parallel Old</td><td>并行</td><td>老年代</td><td>标记-整理</td><td>吞吐量优先</td><td>后台运算不需要太多交互</td></tr><tr><td>CMS</td><td>并发</td><td>老年代</td><td>标记-清除</td><td>响应速度优先</td><td>互联网或B&#x2F;S业务</td></tr><tr><td>G1</td><td>并发、并行</td><td>新生代、老年代</td><td>标记-整理、复制</td><td>响应速度优先</td><td>面向服务端应用</td></tr></tbody></table><h3 id="CMS-回收器：低延迟"><a href="#CMS-回收器：低延迟" class="headerlink" title="CMS 回收器：低延迟"></a><strong>CMS</strong> <strong>回收器：低延迟</strong></h3><p>在 JDK1.5 时期，Hotspot 推出了一款在强交互应用中几乎可认为有划时代意义的垃圾收集器：cMS（Concurrent-Mark-Sweep）收集器，这款收集器是 HotSpot 虚拟机中第一款真正意义上的并发收集器，<strong>它第一次实现了让垃圾收集线程与用户线程同时工作</strong>。</p><p>CMS 收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间。停顿时间越短（低延迟）就越适合与用户交互的程序，良好的响应速度能提升用户体验。目前很大一部分的 Java 应用集中在互联网站或者 B&#x2F;S 系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS 收集器就非常符合这类应用的需求。CMS 的垃圾收集算法采用标记-清除算法，并且也会”stop-the-world”不幸的是，CMS 作为老年代的收集器，却无法与 JDK1.4.0 中已经存在的新生代收集器 Parallel Scavenge 配合工作，所以在 JDK1.5 中使用 CMS 来收集老年代的时候，新生代只能选择 ParNew 或者 Serial 收集器中的一个。在 G1 出现之前，CMS 使用还是非常广泛的。一直到今天，仍然有很多系统使用CMS GC。</p><p>CMS 整个过程比之前的收集器要复杂，整个过程分为 4 个主要阶段，即初始标记阶段、并发标记阶段、重新标记阶段和并发清除阶段。(涉及 <strong>STW</strong> 的阶段主要是：初始标记 和 重新标记) </p><ol><li><strong>初始标记</strong>（Initial-Mark）阶段：在这个阶段中，程序中所有的工作线程都将会因为“stop-the-world”机制而出现短暂的暂停，这个阶段的主要任务仅仅只是<strong>标记出</strong> <strong>GCRoots</strong> <strong>能直接关联到的对象</strong>。一旦标记完成之后就会恢复之前被暂停的所有应用线程。由于直接关联对象比较小，所以这里的速度非常快。</li><li><strong>并发标记</strong>（Concurrent-Mark）阶段：从 Gc Roots 的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行。</li><li><strong>重新标记</strong>（Remark）阶段：由于在并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行或者交叉运行，因此为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短。</li><li><strong>并发清除</strong>（Concurrent-Sweep）阶段：此阶段清理删除掉标记阶段判断的已经死亡的对象，释放内存空间。由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的尽管 CMS 收集器采用的是并发回收（非独占式），但是在其初始化标记和再次标记这两个阶段中仍然需要执行“Stop-the-World”机制暂停程序中的工作线程，不过暂停时间并不会太长，因此可以说明目前所有的垃圾收集器都做不到完全不需要“stop-the-World”，只是尽可能地缩短暂停时间。由于最耗费时间的并发标记与并发清除阶段都不需要暂停工作，所以整体的回收是低停顿的。</li></ol><p>另外，由于在垃圾收集阶段用户线程没有中断，所以在 CMS 回收过程中，还应该确保应用程序用户线程有足够的内存可用。因此，CMS 收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，而是当堆内存使用率达到某一阈值时，便开始进行回收，以确保应用程序在 CMS 工作过程中依然有足够的空间支持应用程序运行。要是 CMS 运行期间预留的内存无法满足程序需要，就会出现一次</p><p>“Concurrent Mode Failure” 失败，这时虚拟机将启动后备预案：临时启用 Serial old收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。CMS 收集器的垃圾收集算法采用的是<strong>标记清除算法</strong>，这意味着每次执行完内存回收后，由于被执行内存回收的无用对象所占用的内存空间极有可能是不连续的一些内存块，不可避免地将会产生一些内存碎片。那么 CMS 在为新对象分配内存空间时，将无法使用指针碰撞（Bump the Pointer）技术，而只能够选择空闲列表（Free List）执行内存分配。</p><p><strong>CMS</strong> <strong>为什么不使用标记整理算法？</strong></p><p>答案其实很简答，因为当并发清除的时候，用 Compact 整理内存的话，原来的用户线程使用的内存还怎么用呢？要保证用户线程能继续执行，前提的它运行的资源不受影响嘛。Mark Compact 更适合“stop the world” 这种场景下使用</p><p><strong>优点</strong></p><ul><li>并发收集</li><li>低延迟</li></ul><p><strong>缺点</strong></p><ul><li>会产生内存碎片，导致并发清除后，用户线程可用的空间不足。在无法分配大对象的情况下，不得不提前触发 FullGC。 </li><li>CMS 收集器对 CPU 资源非常敏感。在并发阶段，它虽然不会导致用户停顿，但是会因为占用了一部分线程而导致应用程序变慢，总吞吐量会降低。</li><li>CMS 收集器无法处理浮动垃圾。可能出现“Concurrent Mode Failure”失败而导致另一次 Full GC 的产生。在并发标记阶段由于程序的工作线程和垃圾收集线程是同时运行或者交叉运行的，那么在并发标记阶段如果产生新的垃圾对象，CMS 将无法对这些垃圾对象进行标记，最终会导致这些新产生的垃圾对象没有被及时回收，从而只能在下一次执行 GC 时释放这些之前未被回收的内存空间。</li></ul><p><strong>设置的参数</strong></p><p>• -XX：+UseConcMarkSweepGC 手动指定使用 CMS 收集器执行内存回收任务。开启该参数后会自动将-xx：+UseParNewGC 打开。即：ParNew（Young 区用）+CMS（01d 区用）+Serial old 的组合。</p><p>• -XX:CMSInitiatingoccupanyFraction 设置堆内存使用率的阈值，一旦达到该阈值，便开始进行回收。JDK5 及以前版本的默认值为 68，即当老年代的空间使用率达到 68%时，会执行一次 cMs 回收。JDK6 及以上版本默认值为 92%如果内存增长缓慢，则可以设置一个稍大的值，大的阀值可以有效降低 CMS 的触发频率，减少老年代回收的次数可以较为明显地改善应用程序性能。反之，如果应用程序内存使用率增长很快，则应该降低这个阈值，以避免频繁触发老年代串行收集器。因此通过该选项便可以有效降低 Ful1Gc 的执行次数。</p><ul><li>-XX：+UseCMSCompactAtFullCollection 用于指定在执行完 Ful1GC 后对内存空间进行压缩整理，以此避免内存碎片的产生。不过由于内存压缩整理过程无法并发执行，所带来的问题就是停顿时间变得更长了。</li><li>-XX:CMSFullGCsBeforecompaction 设置在执行多少次 Ful1GC 后对内存空间进行压缩整理。</li><li>-XX:ParallelcMSThreads 设置 cMs 的线程数量。CMs 默认启动的线程数是（Paralle1GCThreads+3）&#x2F;4，ParallelGCThreads 是年轻代并行收集器的线程数。当 CPU 资源比较紧张时，受到 CMS 收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕。</li></ul><p><strong>小结</strong></p><p>HotSpot 有这么多的垃圾回收器，那么如果有人问，Serial GC、Parallel GC、Concurrent Mark Sweep GC 这三个 Gc 有什么不同呢？</p><p>请记住以下口令：</p><ul><li>如果你想要最小化地使用内存和并行开销，请选 Serial GC； </li><li>如果你想要最大化应用程序的吞吐量，请选 Parallel GC； </li><li>如果你想要最小化 GC 的中断或停顿时间，请选 CMs GC。</li></ul><h3 id="G1垃圾回收器：区域化分代式"><a href="#G1垃圾回收器：区域化分代式" class="headerlink" title="G1垃圾回收器：区域化分代式"></a><strong>G1垃圾回收器</strong>：区域化分代式</h3><p>G1GC 的垃圾回收过程主要包括如下三个环节：</p><ul><li>年轻代 GC（Young GC） </li><li>老年代并发标记过程（Concurrent Marking） </li><li>混合回收（Mixed GC）</li></ul><p>（如果需要，单线程、独占式、高强度的 Fu11GC 还是继续存在的。它针对 GC 的评估失败提供了一种失败保护机制，即强力回收。）</p><p>顺时针，<strong>young gc-&gt;young gc+concurrent mark-&gt;Mixed GC</strong> 顺序，进行垃圾回收。应用程序分配内存，当年轻代的 Eden 区用尽时开始年轻代回收过程；G1 的年轻代收集阶段是一个并行的独占式收集器。在年轻代回收期，G1GC 暂停所有应用程序线程，启动多线程执行年轻代回收。然后从年轻代区间移动存活对象到 Survivor区间或者老年区间，也有可能是两个区间都会涉及。</p><p>当堆内存使用达到一定值（默认 45%）时，开始老年代并发标记过程。标记完成马上开始混合回收过程。对于一个混合回收期，G1GC 从老年区间移动存活对象到空闲区间，这些空闲区间也就成为了老年代的一部分。和年轻代不同，老年代的 G1 回收器和其他 GC 不同，G1 的老年代回收器不需要整个老年代被回收，一次只需要扫描&#x2F;回收一小部分老年代的 Region 就可以了。同时，这个老年代Region 是和年轻代一起被回收的。</p><p>举个例子：一个 Web 服务器，Java 进程最大堆内存为 4G，每分钟响应 1500 个请求，每 45 秒钟会新分配大约 2G 的内存。G1 会每 45 秒钟进行一次年轻代回收，每 31 个小时整个堆的使用率会达到 45%，会开始老年代并发标记过程，标记完成后开始四到五次的混合回收。</p><p><strong>Remembered Set****（记忆集）</strong></p><p>一个对象被不同区域引用的问题一个 Region 不可能是孤立的，一个 Region 中的对象可能被其他任意 Region 中对象引用，判断对象存活时，是否需要扫描整个 Java 堆才能保证准确？在其他的分代收集器，也存在这样的问题（而 G1 更突出）回收新生代也不得不同时扫描老年代？这样的话会降低 MinorGC 的效率；</p><p><strong>解决方法：</strong></p><p>无论 G1 还是其他分代收集器，JVM 都是使用 Remembered Set 来避免全局扫描：每个 Region 都有一个对应的 Remembered Set；每次 Reference 类型数据写操作时，都会产生一个 Write Barrier 暂时中断操作；然后检查将要写入的引用指向的对象是否和该 Reference 类型数据在不同的Region（其他收集器：检查老年代对象是否引用了新生代对象）；如果不同，通过cardTable 把相关引用信息记录到引用指向对象的所在 Region 对应的Remembered Set 中；当进行垃圾收集时，在 GC 根节点的枚举范围加入Remembered Set；就可以保证不进行全局扫描，也不会有遗漏。</p><p><strong>G1</strong> <strong>回收过程年轻代GC</strong></p><p>JVM 启动时，G1 先准备好 Eden 区，程序在运行过程中不断创建对象到 Eden 区，当 Eden 空间耗尽时，G1 会启动一次年轻代垃圾回收过程。YGC 时，首先 G1 停止应用程序的执行（stop-The-Wor1d），G1 创建回收集（Collection Set），回收集是指需要被回收的内存分段的集合，年轻代回收过程的回收集包含年轻代 Eden 区和 Survivor 区所有的内存分段。</p><p>然后开始如下回收过程：</p><ul><li>第一阶段，扫描根：根是指 static 变量指向的对象，正在执行的方法调用链条上的局部变量等。根引用连同 RSet 记录的外部引用作为扫描存活对象的入口。</li><li>第二阶段，更新 RSet：处理 dirty card queue（见备注）中的 card，更新 RSet。此阶段完成后，RSet 可以准确的反映老年代对所在的内存分段中对象的引用。</li><li>第三阶段，处理 RSet：识别被老年代对象指向的 Eden 中的对象，这些被指向的 Eden 中的对象被认为是存活的对象。</li><li>第四阶段，复制对象:此阶段，对象树被遍历，Eden 区内存段中存活的对象会被复制到 Survivor 区中空的内存分段，Survivor 区内存段中存活的对象如果年龄未达阈值，年龄会加 1，达到阀值会被会被复制到 o1d 区中空的内存分段。如果 Survivor 空间不够，Eden 空间的部分数据会直接晋升到老年代空间。</li><li>第五阶段，处理引用:处理 Soft，Weak，Phantom，Final，JNI Weak 等引用。最终 Eden 空间的数据为空，GC 停止工作，而目标内存中的对象都是连续存储的，没有碎片，所以复制过程可以达到内存整理的效果，减少碎片。</li></ul><p><strong>G1</strong> <strong>回收过程并发标记过程</strong></p><ul><li>初始标记阶段：标记从根节点直接可达的对象。这个阶段是 sTw 的，并且会触发一次年轻代 GC。 </li><li>根区域扫描（Root Region Scanning）：G1 Gc 扫描 survivor 区直接可达的老年代区域对象，并标记被引用的对象。这一过程必须在youngGC 之前完成。</li><li>并发标记（Concurrent Marking）：在整个堆中进行并发标记（和应用程序并发执行），此过程可能被 youngGC 中断。在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那这个区域会被立即回收。同时，并发标记过程中，会计算每个区域的对象活性（区域中存活对象的比例）。</li><li>再次标记（Remark）：由于应用程序持续进行，需要修正上一次的标记结果。是 STW 的。G1 中采用了比 CMS 更快的初始快照算法：snapshot-at-the-beginning（SATB）。</li><li>独占清理（cleanup，STW）：计算各个区域的存活对象和 GC 回收比例，并进行排序，识别可以混合回收的区域。为下阶段做铺垫。是 STW 的。这个阶段并不会实际上去做垃圾的收集。</li><li>并发清理阶段：识别并清理完全空闲的区域。</li></ul><p><strong>G1</strong> <strong>回收过程混合回收</strong></p><p>当越来越多的对象晋升到老年代 o1d region 时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即 Mixed GC，该算法并不是一个 old GC，除了回收整个 Young Region，还会回收一部分的 old Region。这里需要注意：<strong>是一部分老****年代，而不是全部老年代</strong>。可以选择哪些 o1d Region 进行收集，从而可以对垃圾回收的耗时时间进行控制。也要注意的是 Mixed GC 并不是 Full GC。</p><p>并发标记结束以后，老年代中百分百为垃圾的内存分段被回收了，部分为垃圾的内存分段被计算了出来。默认情况下，这些老年代的内存分段会分 8 次（可以通过-XX:G1MixedGCCountTarget 设置）被回收混合回收的回收集（Collection Set）包括八分之一的老年代内存分段，Eden 区内存分段，Survivor 区内存分段。混合回收的算法和年轻代回收的算法完全一样，只是回收集多了老年代的内存分段。具体过程请参考上面的年轻代回收过程。由于老年代中的内存分段默认分 8 次回收，G1 会优先回收垃圾多的内存分段。垃圾占内存分段比例越高的，越会被先回收。并且有一个阈值会决定内存分段是否被回收，XX:G1MixedGCLiveThresholdPercent，默认为 65%，意思是垃圾占内存分段比例要达到 65%才会被回收。如果垃圾占比太低，意味着存活的对象占比高，在复制的时候会花费更多的时间。混合回收并不一定要进行 8 次。有一个阈值-XX:G1HeapWastePercent，默认值为1e%，意思是允许整个堆内存中有 10%的空间被浪费，意味着如果发现可以回收的垃圾占堆内存的比例低于 1e%，则不再进行混合回收。因为 GC 会花费很多的时间但是回收到的内存却很少。</p><p><strong>G1</strong> <strong>回收可选的过程4 - Full GC</strong></p><p>G1 的初衷就是要避免 Fu11GC 的出现。但是如果上述方式不能正常工作，G1 会停止应用程序的执行（stop-The-world），使用单线程的内存回收算法进行垃圾回收，性能会非常差，应用程序停顿时间会很长。要避免 Fu11GC 的发生，一旦发生需要进行调整。什么时候会发生 Ful1GC 呢？比如堆内存太小，当 G1 在复制存活对象的时候没有空的内存分段可用，则会回退到ful1gc，这种情况可以通过增大内存解决。 导致 61Fu11GC 的原因可能有两个：</p><ul><li>EVacuation 的时候没有足够的 to-space 来存放晋升的对象； </li><li>并发处理过程完成之前空间耗尽。</li></ul><p><strong>G1</strong> <strong>回收的优化建议</strong></p><p>从 oracle 官方透露出来的信息可获知，回收阶段（Evacuation）其实本也有想过设计成与用户程序一起并发执行，但这件事情做起来比较复杂，考虑到 G1 只是回一部分 Region，停顿时间是用户可控制的，所以并不迫切去实现，而选择把这个特性放到了 G1 之后出现的低延迟垃圾收集器（即 ZGC）中。另外，还考虑到 G1不是仅仅面向低延迟，停顿用户线程能够最大幅度提高垃圾收集效率，为了保证吞吐量所以才选择了完全暂停用户线程的实现方案。</p><p>年轻代大小</p><ul><li>避免使用-Xmn 或-XX:NewRatio 等相关选项显式设置年轻代大小。固定年轻代的大小会覆盖。</li><li>暂停时间目标暂停时间目标不要太过严苛。</li><li>G1 GC 的吞吐量目标是 90%的应用程序时间和 10%的垃圾回收时间。</li><li>评估 G1GC 的吞吐量时，暂停时间目标不要太严苛。目标太过严苛表示你愿意承受更多的垃圾回收开销，而这些会直接影响到吞吐量。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构和算法</title>
      <link href="/2022/06/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
      <url>/2022/06/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  LeetCode16</span></span><br><span class="line"><span class="comment">  三数之和</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> threeSumClosest(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, -<span class="number">4</span>&#125;, <span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;i = &quot;</span> + i);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">threeSumClosest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> nums[<span class="number">0</span>] + nums[<span class="number">1</span>] + nums[<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> i + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> len - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[i] + nums[start] + nums[end];</span><br><span class="line">                <span class="keyword">if</span> (Math.abs(res - target) &gt; Math.abs(sum - target)) &#123;</span><br><span class="line">                    res = sum;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">                    end--;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">                    start++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 反转链表</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        ListNode pre=<span class="literal">null</span>;</span><br><span class="line">        ListNode cur=head;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="literal">null</span>)&#123;</span><br><span class="line">            ListNode next=cur.next;</span><br><span class="line">            cur.next=pre;</span><br><span class="line">            pre=cur;</span><br><span class="line">            cur=next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，</span></span><br><span class="line"><span class="comment"> * 并且每个节点只能存储 一位 数字。</span></span><br><span class="line"><span class="comment"> * 请你将两个数相加，并以相同形式返回一个表示和的链表。</span></span><br><span class="line"><span class="comment"> * 你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TwoSum</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> cur;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="literal">null</span> &amp;&amp; l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            sum = l1.val + l2.val + count;</span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">            <span class="keyword">if</span> (sum &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">                cur.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(sum - <span class="number">10</span>);</span><br><span class="line">                count++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(sum);</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (l1 != <span class="literal">null</span>) &#123;</span><br><span class="line">                sum = l1.val + count;</span><br><span class="line">                count = <span class="number">0</span>;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">                <span class="keyword">if</span> (sum &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">                    cur.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(sum - <span class="number">10</span>);</span><br><span class="line">                    count++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    cur.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(sum);</span><br><span class="line">                &#125;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">                sum = l2.val + count;</span><br><span class="line">                count = <span class="number">0</span>;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">                <span class="keyword">if</span> (sum &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">                    cur.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(sum - <span class="number">10</span>);</span><br><span class="line">                    count++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    cur.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(sum);</span><br><span class="line">                &#125;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1 != <span class="literal">null</span>) &#123;</span><br><span class="line">                cur.next = l1;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">                cur.next = l2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count != <span class="number">0</span>) &#123;</span><br><span class="line">            cur.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 栈实现队列</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stack1=<span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stack2=<span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        stack1=<span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        stack2=<span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        stack1.add(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">          <span class="keyword">if</span>(!stack2.isEmpty())</span><br><span class="line">            <span class="keyword">return</span> stack2.pop();</span><br><span class="line">        <span class="comment">// if(stack1.isEmpty())</span></span><br><span class="line">        <span class="comment">//     return null;</span></span><br><span class="line">        <span class="keyword">while</span>(!stack1.isEmpty())&#123;</span><br><span class="line">            stack2.add(stack1.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!stack2.isEmpty())</span><br><span class="line">            <span class="keyword">return</span> stack2.peek();</span><br><span class="line">        <span class="comment">// if(stack1.isEmpty())</span></span><br><span class="line">        <span class="comment">//     return null;</span></span><br><span class="line">        <span class="keyword">while</span>(!stack1.isEmpty())&#123;</span><br><span class="line">            stack2.add(stack1.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack2.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stack1.isEmpty()&amp;&amp;stack2.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 队列实现栈</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line">    Queue&lt;Integer&gt; queue1;</span><br><span class="line">    Queue&lt;Integer&gt; queue2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">()</span> &#123;</span><br><span class="line">        queue1 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">        queue2 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x onto stack. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        queue2.offer(x);</span><br><span class="line">        <span class="keyword">while</span> (!queue1.isEmpty()) &#123;</span><br><span class="line">            queue2.offer(queue1.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;Integer&gt; temp = queue1;</span><br><span class="line">        queue1 = queue2;</span><br><span class="line">        queue2 = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queue1.poll();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the top element. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queue1.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the stack is empty. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queue1.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 顺序遍历</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] levelOrder(TreeNode root) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        Queue&lt;TreeNode&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        LinkedList&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        que.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> que.poll();</span><br><span class="line">            ans.add(cur.val);</span><br><span class="line">            <span class="keyword">if</span> (cur.left != <span class="literal">null</span>) que.add(cur.left);</span><br><span class="line">            <span class="keyword">if</span> (cur.right != <span class="literal">null</span>) que.add(cur.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> ans.size();</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[size];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            res[i] = ans.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="八大排序"><a href="#八大排序" class="headerlink" title="八大排序"></a>八大排序</h2><table><thead><tr><th>排序法</th><th>平均时间</th><th>最差时间</th><th>稳定性</th><th>空间复杂度</th><th>备注（n数量）</th></tr></thead><tbody><tr><td>冒泡</td><td>O(N^2)</td><td>O(N^2)</td><td>稳定</td><td>O(1)</td><td>n小时较好</td></tr><tr><td>选择</td><td>O(N^2)</td><td>O(N^2)</td><td>不稳定</td><td>O(1)</td><td>n小时较好</td></tr><tr><td>插入</td><td>O(N^2)</td><td>O(N^2)</td><td>稳定</td><td>O(1)</td><td>大部分排好序的</td></tr><tr><td>希尔</td><td>O(NlongN)</td><td>O(N^s)1&lt;s&lt;2</td><td>不稳定</td><td>O(1)</td><td>s是所选分组</td></tr><tr><td>快速</td><td>O(NlogN)</td><td>O(N^2)</td><td>不稳定</td><td>O(NlogN)</td><td>n大时较好</td></tr><tr><td>归并</td><td>O(NlongN)</td><td>O(NlongN)</td><td>稳定</td><td>O(1)</td><td>n大时较好</td></tr><tr><td>基数</td><td>O(longRB)</td><td>O(longRB)</td><td>稳定</td><td>O(N)</td><td>B真数（0-9）R基数</td></tr><tr><td>堆</td><td>O(NlogN)</td><td>O(NlogN)</td><td>不稳定</td><td>O(1)</td><td>n大时较好</td></tr></tbody></table><h3 id="冒泡"><a href="#冒泡" class="headerlink" title="冒泡"></a>冒泡</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;<span class="comment">//如果是已经排序好的,直接退出</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                    temp = arr[j];</span><br><span class="line">                    arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                    arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;第&quot;</span> + (i + <span class="number">1</span>) + <span class="string">&quot;趟排序的数组&quot;</span> + Arrays.toString(arr));</span><br><span class="line">            <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">           <span class="type">int</span> <span class="variable">minIndex</span> <span class="operator">=</span> i;</span><br><span class="line">           <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> arr[i];</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">               <span class="keyword">if</span> (min &gt; arr[j]) &#123;</span><br><span class="line">                   min = arr[j];</span><br><span class="line">                   minIndex = j;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (minIndex != i) &#123;<span class="comment">//优化</span></span><br><span class="line">               arr[minIndex] = arr[i];</span><br><span class="line">               arr[i] = min;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">insertIndex</span> <span class="operator">=</span> i - <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">insertVal</span> <span class="operator">=</span> arr[i];</span><br><span class="line">            <span class="keyword">while</span> (insertIndex &gt;= <span class="number">0</span> &amp;&amp; insertVal &lt; arr[insertIndex]) &#123;</span><br><span class="line">                arr[insertIndex + <span class="number">1</span>] = arr[insertIndex];</span><br><span class="line">                insertIndex--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (insertIndex + <span class="number">1</span> != i) &#123;<span class="comment">//优化</span></span><br><span class="line">                arr[insertIndex + <span class="number">1</span>] = insertVal;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;第&quot;</span> + i + <span class="string">&quot;次插入&quot;</span> + Arrays.toString(arr));</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="希尔"><a href="#希尔" class="headerlink" title="希尔"></a>希尔</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">insertIndex</span> <span class="operator">=</span> i - <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">insertVal</span> <span class="operator">=</span> arr[i];</span><br><span class="line">            <span class="keyword">while</span> (insertIndex &gt;= <span class="number">0</span> &amp;&amp; insertVal &lt; arr[insertIndex]) &#123;</span><br><span class="line">                arr[insertIndex + <span class="number">1</span>] = arr[insertIndex];</span><br><span class="line">                insertIndex--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (insertIndex + <span class="number">1</span> != i) &#123;<span class="comment">//优化</span></span><br><span class="line">                arr[insertIndex + <span class="number">1</span>] = insertVal;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;第&quot;</span> + i + <span class="string">&quot;次插入&quot;</span> + Arrays.toString(arr));</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">     <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> left;</span><br><span class="line">     <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> right;</span><br><span class="line">     <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> arr[(left + right) / <span class="number">2</span>];<span class="comment">//中轴值</span></span><br><span class="line">     <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">     <span class="comment">//while目的是让比pivot值小的放在左边,大的放在右边</span></span><br><span class="line">     <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">         <span class="comment">//在pivot左边一直找</span></span><br><span class="line">         <span class="keyword">while</span> (arr[l] &lt; pivot) &#123;</span><br><span class="line">             l += <span class="number">1</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//在pivot右边一直找,直到找到小于等于才退出</span></span><br><span class="line">         <span class="keyword">while</span> (arr[r] &gt; pivot) &#123;</span><br><span class="line">             r -= <span class="number">1</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//如果成立,说明pivot左边是小于等于pivot,而右边是大于等于pivot的值</span></span><br><span class="line">         <span class="keyword">if</span> (l &gt;= r) &#123;</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         temp = arr[l];</span><br><span class="line">         arr[l] = arr[r];</span><br><span class="line">         arr[r] = temp;</span><br><span class="line">         <span class="comment">//这里的if是判断当如果pivot左右俩边出现等于pivot的情况</span></span><br><span class="line">         <span class="keyword">if</span> (arr[l] == pivot) &#123;</span><br><span class="line">             r -= <span class="number">1</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (arr[r] == pivot) &#123;</span><br><span class="line">             l += <span class="number">1</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//如果l==r,需处理不然会栈溢出</span></span><br><span class="line">     <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">         l += <span class="number">1</span>;</span><br><span class="line">         r -= <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//向左递归</span></span><br><span class="line">     <span class="keyword">if</span> (left &lt; r) &#123;</span><br><span class="line">         quickSort(arr, left, r);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//向右递归</span></span><br><span class="line">     <span class="keyword">if</span> (right &gt; l) &#123;</span><br><span class="line">         quickSort(arr, l, right);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="归并"><a href="#归并" class="headerlink" title="归并"></a>归并</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> merge;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MergeSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">35</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">99</span>, <span class="number">6</span>, <span class="number">87</span>, <span class="number">8</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">R</span> <span class="operator">=</span> arr.length - <span class="number">1</span>;</span><br><span class="line">        process(arr, L, R);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> L, <span class="type">int</span> R)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (L == R) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> L + ((R - L) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        process(arr, L, mid);</span><br><span class="line">        process(arr, mid + <span class="number">1</span>, R);</span><br><span class="line">        mergeSort(arr, L, mid, R);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> L, <span class="type">int</span> mid, <span class="type">int</span> R)</span> &#123;</span><br><span class="line">        <span class="type">int</span> help[] = <span class="keyword">new</span> <span class="title class_">int</span>[R - L + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> L;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (p1 &lt;= mid &amp;&amp; p2 &lt;= R) &#123;</span><br><span class="line">            help[i++] = arr[p1] &lt;= arr[p2] ? arr[p1++] : arr[p2++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p1 &lt;= mid) &#123;</span><br><span class="line">            help[i++] = arr[p1++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p2 &lt;= R) &#123;</span><br><span class="line">            help[i++] = arr[p2++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; help.length; j++) &#123;</span><br><span class="line">            arr[L + j] = help[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="基数"><a href="#基数" class="headerlink" title="基数"></a>基数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个二维数组表示10个桶</span></span><br><span class="line"><span class="type">int</span> bucket[][] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>][arr.length];</span><br><span class="line"><span class="comment">//表示每个桶中元素个数</span></span><br><span class="line"><span class="type">int</span> bucketElementCounts[] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">  <span class="comment">//假定arr[0]最大</span></span><br><span class="line"><span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[i] &gt; max) &#123;</span><br><span class="line">        max = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//计算出最大整数的位数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">maxLength</span> <span class="operator">=</span> (max + <span class="string">&quot;&quot;</span>).length();</span><br><span class="line"><span class="comment">//n表示被除的</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, n = <span class="number">1</span>; i &lt; maxLength; i++, n *= <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">wei</span> <span class="operator">=</span> arr[j] / n % <span class="number">10</span>;</span><br><span class="line">        <span class="comment">//放入对应的桶中</span></span><br><span class="line">        bucket[wei][bucketElementCounts[wei]] = arr[j];</span><br><span class="line">        bucketElementCounts[wei]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//取出桶中的数据,放回到arr数组中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; bucketElementCounts.length; k++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bucketElementCounts[k] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>; l &lt; bucketElementCounts[k]; l++) &#123;</span><br><span class="line">                arr[index++] = bucket[k][l];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        bucketElementCounts[k] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;第&quot;</span> + (i + <span class="number">1</span>) + <span class="string">&quot;轮&quot;</span> + Arrays.toString(arr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BigHeap</span> &#123; <span class="comment">//实现升序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> nums[] = &#123; <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>,  <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span> (len &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//1、找到大顶堆</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            bigHeap(nums, i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、对实现的大顶堆进行整理[6,,4,5,2,3,1]</span></span><br><span class="line">        <span class="keyword">while</span> (--len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            swap(nums, <span class="number">0</span>, len);</span><br><span class="line">            heapIfy(nums, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(Arrays.toString(nums));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums 数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i 0每次和根节点进行比较交换</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> len 数组变化的长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapIfy</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; len) &#123;</span><br><span class="line">            <span class="comment">//找到左右孩子较大的取出下标</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">largest</span> <span class="operator">=</span> left + <span class="number">1</span> &lt; len &amp;&amp; nums[left + <span class="number">1</span>] &gt; nums[left] ? left + <span class="number">1</span> : left;</span><br><span class="line">            <span class="comment">//比较找的较大的孩子与当前值比较</span></span><br><span class="line">            largest = nums[largest] &gt; nums[i] ? largest : i;</span><br><span class="line">            <span class="keyword">if</span> (largest == i) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(nums, largest, i);</span><br><span class="line">            left = i * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数组实现大顶堆</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bigHeap</span><span class="params">(<span class="type">int</span> nums[], <span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (nums[index] &gt; nums[(index - <span class="number">1</span>) / <span class="number">2</span>]) &#123;</span><br><span class="line">            swap(nums, index, (index - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">            index = (index - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> index1, <span class="type">int</span> index2)</span> &#123;</span><br><span class="line">        nums[index1] = nums[index1] ^ nums[index2];</span><br><span class="line">        nums[index2] = nums[index1] ^ nums[index2];</span><br><span class="line">        nums[index1] = nums[index1] ^ nums[index2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="二分搜索"><a href="#二分搜索" class="headerlink" title="二分搜索"></a>二分搜索</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  LeetCode34</span></span><br><span class="line"><span class="comment">  给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。</span></span><br><span class="line"><span class="comment">  如果数组中不存在目标值 target，返回 [-1, -1]。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] searchRange(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftIndex</span> <span class="operator">=</span> binarySearch(nums, target, <span class="literal">true</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightIndex</span> <span class="operator">=</span> binarySearch(nums, target, <span class="literal">false</span>) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (leftIndex &lt;= rightIndex)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;leftIndex, rightIndex&#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span> nums[], <span class="type">int</span> target, <span class="type">boolean</span> flag)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> right + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; target || (flag &amp;&amp; nums[mid] &gt;= target)) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">                ans = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3</span></span><br><span class="line"><span class="comment">    输出：true</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">searchMatrix</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> row=matrix.length-<span class="number">1</span>,col=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(row&gt;=<span class="number">0</span> &amp;&amp; col&lt;matrix[<span class="number">0</span>].length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[row][col]&gt;target)&#123;</span><br><span class="line">                row--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(matrix[row][col]&lt;target)&#123;</span><br><span class="line">                col++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">输入：nums = [4,5,6,7,0,1,2], target = 0</span></span><br><span class="line"><span class="comment">输出：4</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(len== <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>]==target?<span class="number">0</span>:-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>,right=len-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            <span class="type">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]==target)&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt;=nums[<span class="number">0</span>])&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[<span class="number">0</span>]&lt;=target&amp;&amp;nums[mid]&gt;=target)&#123;</span><br><span class="line">                    right=mid-<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    left=mid+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[len-<span class="number">1</span>]&gt;=target&amp;&amp;nums[mid]&lt;=target)&#123;</span><br><span class="line">                  left=mid+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    right=mid-<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="dfs"><a href="#dfs" class="headerlink" title="dfs"></a>dfs</h3><h3 id="bfs"><a href="#bfs" class="headerlink" title="bfs"></a>bfs</h3><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）</span></span><br><span class="line"><span class="comment">*输入：head = [1,2,3,4]</span></span><br><span class="line"><span class="comment">*输出：[2,1,4,3]</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span> || head.next == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> head.next;</span><br><span class="line">        head.next = swapPairs(next.next);</span><br><span class="line">        next.next = head;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h3><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。</span></span><br><span class="line"><span class="comment"> 你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。</span></span><br><span class="line"><span class="comment"> 返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> prices.length;</span><br><span class="line">        <span class="comment">// for(int i=0;i&lt;len;i++)&#123;</span></span><br><span class="line">        <span class="comment">//     for(int j=i+1;j&lt;len;j++)&#123;</span></span><br><span class="line">        <span class="comment">//         int price=prices[j]-prices[i];</span></span><br><span class="line">        <span class="comment">//         res=Math.max(res,price);</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">minValue</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prices[i] &lt; minValue) &#123;</span><br><span class="line">                minValue = prices[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (prices[i] - minValue &gt; res) &#123;</span><br><span class="line">                    res = prices[i] - minValue;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">n个孩子站成一排。给你一个整数数组 ratings 表示每个孩子的评分。</span></span><br><span class="line"><span class="comment">你需要按照以下要求，给这些孩子分发糖果：</span></span><br><span class="line"><span class="comment">每个孩子至少分配到 1 个糖果。相邻两个孩子评分更高的孩子会获得更多的糖果。</span></span><br><span class="line"><span class="comment">请你给每个孩子分发糖果，计算并返回需要准备的最少糖果数目。 </span></span><br><span class="line"><span class="comment">输入：ratings = [1,2,5,1]</span></span><br><span class="line"><span class="comment">输出：5</span></span><br><span class="line"><span class="comment">解释：你可以分别给第一个、第二个、第三个孩子、第四个分发 1、2、2、1 颗糖果。</span></span><br><span class="line"><span class="comment">     第三个孩子只得到 1 颗糖果，这满足题面中的两个条件。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">candy</span><span class="params">(<span class="type">int</span>[] ratings)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> ratings.length;</span><br><span class="line">        <span class="type">int</span>[] left = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; ratings[i] &gt; ratings[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                left[i] = left[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left[i] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>, ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; len - <span class="number">1</span> &amp;&amp; ratings[i] &gt; ratings[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                right++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ret += Math.max(left[i], right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h2><h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 输入：11111111111111111111111111111101</span></span><br><span class="line"><span class="comment"> * 输出：31</span></span><br><span class="line"><span class="comment"> * 解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 &#x27;1&#x27;。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hammingWeight</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// String s = Integer.toBinaryString(n);</span></span><br><span class="line">        <span class="comment">// for(int i=0;i&lt;s.length();i++)&#123;</span></span><br><span class="line">        <span class="comment">//     if(s.charAt(i)==&#x27;1&#x27;)&#123;</span></span><br><span class="line">        <span class="comment">//         count++;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((n &amp; (<span class="number">1</span> &lt;&lt; i)) != <span class="number">0</span>) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> LeetCode14</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ZuiChangGongGonZiChuan</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//foot&quot;,&quot;flow&quot;,&quot;flight--&gt;输出 f</span></span><br><span class="line">        String[] strs = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;flower&quot;</span>, <span class="string">&quot;flow&quot;</span>, <span class="string">&quot;flight&quot;</span>&#125;;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> longestCommonPrefix(strs);<span class="comment">//输出fl</span></span><br><span class="line"></span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">longestCommonPrefix</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (strs == <span class="literal">null</span> || strs.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> strs[<span class="number">0</span>].length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> strs.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> strs[<span class="number">0</span>].charAt(i);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; count; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == strs[j].length() || strs[j].charAt(i) != c) &#123;</span><br><span class="line">                    <span class="keyword">return</span> strs[<span class="number">0</span>].substring(<span class="number">0</span>, i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> strs[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="滑动窗口（KMP）"><a href="#滑动窗口（KMP）" class="headerlink" title="滑动窗口（KMP）"></a>滑动窗口（KMP）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB</title>
      <link href="/2022/06/28/MongoDB/"/>
      <url>/2022/06/28/MongoDB/</url>
      
        <content type="html"><![CDATA[<h2 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ</title>
      <link href="/2022/06/28/RabbitMQ/"/>
      <url>/2022/06/28/RabbitMQ/</url>
      
        <content type="html"><![CDATA[<h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis</title>
      <link href="/2022/06/28/Redis/"/>
      <url>/2022/06/28/Redis/</url>
      
        <content type="html"><![CDATA[<h2 id="NoSQL数据库"><a href="#NoSQL数据库" class="headerlink" title="NoSQL数据库"></a>NoSQL数据库</h2><ul><li>不遵循SQL标准。</li><li>不支持ACID。</li><li>远超SQL的性能。</li></ul><p><strong>NoSQL 适用场景</strong> :</p><ul><li>对数据高并发的读写 。</li><li>海量数据的读写 。</li><li>对数据高可扩展性的。</li><li>用不着sql的和用了sql也不行的情况</li></ul><p><strong>NoSQL 不适用场景</strong> :</p><ul><li>需要事务支持 。</li><li>基于 sql 的结构化查询存储，处理复杂的关系,需要<strong>即席</strong>查询。</li></ul><h2 id="常用五大数据类型"><a href="#常用五大数据类型" class="headerlink" title="常用五大数据类型"></a><strong>常用五大数据类型</strong></h2><img src="https://cdn.jsdelivr.net/gh/XueZhengXiang/photo/img/redis五大类型.png" style="zoom:120%;"><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>String 类型是二进制安全的。意味着 Redis 的 string 可以包含任何数据。比如 jpg 图片 或者序列化的对象。 </p><p>String 的数据结构为简单动态字符串(Simple Dynamic String,缩写 SDS)。是可以 修改的字符串，内部结构实现上类似于 Java 的 ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set k <span class="number">1</span></span><br><span class="line">get k</span><br><span class="line">incr k</span><br><span class="line">decr k</span><br><span class="line">setex k 过期时间 v</span><br></pre></td></tr></table></figure><h3 id="List-快速链表-quickList"><a href="#List-快速链表-quickList" class="headerlink" title="List(快速链表 quickList)"></a>List(快速链表 quickList)</h3><p><strong>单键多值</strong> </p><p>Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头 部（左边）或者尾部（右边）。它的底层实际是个<strong>双向链表</strong>，对两端的操作性能很高，通过索引下标的操作中间的节点性能会较差。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rpush k <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line">lrange k <span class="number">0</span> -<span class="number">1</span> <span class="comment">//查询所有</span></span><br><span class="line">lindex k <span class="number">0</span> <span class="comment">//查第一个</span></span><br></pre></td></tr></table></figure><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>Redis set 对外提供的功能与 list 类似是一个列表的功能，特殊之处在于 set 是可以<strong>自动排重</strong>的，当你需要存储一个列表数据，又不希望出现重复数据时，set 是一个很好的选 择，并且 set 提供了判断某个成员是否在一个 set 集合内的重要接口，这个也是 list 所 不能提供的。 </p><p>Redis 的 Set 是 String 类型的无序集合。它底层其实是一个 value 为 null 的 hash 表，所以添加，删除，查找的<strong>复杂度都是</strong> **O(1)**。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sadd k <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">3</span> <span class="number">4</span> <span class="number">4</span></span><br><span class="line">smembers k <span class="comment">//取出该集合的所有值</span></span><br><span class="line">sismember k <span class="number">3</span> <span class="comment">//判断集合k是否为含有该1值，有返回1，没有返回0</span></span><br></pre></td></tr></table></figure><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>Redis hash 是一个键值对集合。 </p><p>Redis hash 是一个 string 类型的 <strong>field</strong> 和 <strong>value</strong> 的映射表，hash 特别适合用于存储对象。 类似 Java 里面的 Map&lt;String,Object&gt; </p><p>用户 ID 为查找的 key，存储的 value 用户对象包含姓名，年龄，生日等信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hset k <span class="number">1</span> <span class="string">&quot;zhangsan&quot;</span> <span class="number">2</span> <span class="string">&quot;lisi&quot;</span></span><br><span class="line">hget k <span class="number">1</span> <span class="comment">//查询字段为1的value----&gt;&quot;zhangsan&quot;</span></span><br><span class="line">hget k <span class="number">2</span></span><br><span class="line">hkeys k <span class="comment">//查询所有的filed-----&gt; 1  2</span></span><br><span class="line">hvals k <span class="comment">//查询所有的value-----&gt;&quot;zhangsan&quot;  &quot;lisi&quot;</span></span><br></pre></td></tr></table></figure><h3 id="Zset"><a href="#Zset" class="headerlink" title="Zset"></a>Zset</h3><p>Redis 有序集合 zset 与普通集合 set 非常相似，是一个没有重复元素的字符串集合。 </p><p>不同之处是有序集合的每个成员都关联了一个<strong>评分（score）</strong>,这个评分（score）被用 来按照从最低分到最高分的方式排序集合中的成员。集合的成员是唯一的，但是评分 可以是重复了 。 </p><p>因为元素是有序的, 所以你也可以很快的根据评分（score）或者次序（position）来获取一个范围的元素。 </p><p>访问有序集合的中间元素也是非常快的,因此你能够使用有序集合作为一个没有重复成 员的智能列表。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zadd k <span class="number">10</span> <span class="string">&quot;zhangsan&quot;</span> <span class="number">20</span> <span class="string">&quot;lisi&quot;</span> <span class="number">30</span> <span class="string">&quot;wangwu&quot;</span></span><br><span class="line">zrange k <span class="number">0</span> <span class="number">2</span> withscores <span class="comment">//&quot;zhangsan&quot;10 &quot;lisi&quot;20 &quot;wangwu&quot;30</span></span><br></pre></td></tr></table></figure><p><strong>Zset</strong> 底层使用了两个数据结构 :</p><ol><li><strong>hash</strong>，hash 的作用就是关联元素 value 和权重 score，保障元素 value 的唯 一性，可以通过元素 value 找到相应的 score 值。 </li><li><strong>跳跃表</strong>，跳跃表的目的在于给元素 value 排序，根据 score 的范围获取元素列表。</li></ol><h3 id="Redis-的发布和订阅"><a href="#Redis-的发布和订阅" class="headerlink" title="Redis 的发布和订阅"></a><strong>Redis 的发布和订阅</strong></h3><p>Redis 发布订阅 (pub&#x2F;sub) 是一种消息通信模式：发送者 (pub) 发送消息，订阅者 (sub) 接收消息。 </p><p>Redis 客户端可以订阅任意数量的频道。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、打开一个客户端订阅 channel1 </span></span><br><span class="line">SUBSCRIBE channel1 </span><br><span class="line"><span class="comment">//2、打开另一个客户端，给 channel1 发布消息 hello</span></span><br><span class="line">publish channel1 hello 返回的 <span class="number">1</span> 是订阅者数量 </span><br><span class="line"><span class="comment">//3、打开第一个客户端可以看到发送的消息</span></span><br></pre></td></tr></table></figure><h2 id="Redis-新数据类型"><a href="#Redis-新数据类型" class="headerlink" title="Redis 新数据类型"></a><strong>Redis 新数据类型</strong></h2><h3 id="BitMaps"><a href="#BitMaps" class="headerlink" title="BitMaps"></a>BitMaps</h3><p>现代计算机用二进制（位） 作为信息的基础单位， 1 个字节等于 8 位， 例如“abc” 字符串是由 3 个字节组成， 但实际在计算机存储时将其用二进制表示， “abc”分别 对应的 ASCII 码分别是 97、 98、 99， 对应的二进制分别是 01100001、 01100010 和 01100011，合理地使用操作位能够有效地提高内存使用率和开发效率。 </p><p>Redis 提供了 Bitmaps 这个“数据类型”可以实现对<strong>位的操作</strong>： </p><ol><li>Bitmaps 本身不是一种数据类型， 实际上它就是字符串（key-value） ， 但是它可以对字符串的位进行操作。 </li><li>Bitmaps 单独提供了一套命令， 所以在 Redis 中使用 Bitmaps 和使用字 符串的方法不太相同。 可以把 Bitmaps 想象成一个以位为单位的数组， 数组的每个单元只能存储 0 和 1, 数组的下标在 Bitmaps 中叫做偏移量。</li></ol><h3 id="Bitmaps-与-set-对比"><a href="#Bitmaps-与-set-对比" class="headerlink" title="Bitmaps 与 set 对比"></a><strong>Bitmaps 与 set 对比</strong></h3><p>假设网站有 1 亿用户， 每天独立访问的用户有 5 千万， 如果每天用集合类型和 Bitmaps 分别存储活跃用户可以得到表 ：</p><p>BitMaps与Set存储一天用户对比：</p><table><thead><tr><th>数据类型</th><th>每个用户id占用空间</th><th>需要存储的用户量</th><th>全部内存量</th></tr></thead><tbody><tr><td>集合类型</td><td>64位</td><td>50，000，000</td><td>64*50000000&#x3D;400M</td></tr><tr><td>BitMaps</td><td>1位</td><td>100，000,000</td><td>1*100000000&#x3D;12.5M</td></tr></tbody></table><p><strong>优点：</strong>很明显， 这种情况下使用 Bitmaps 能节省很多的内存空间， 尤其是随着时间推 移节省的内存还是非常可观的 。</p><table><thead><tr><th>数据类型</th><th>一天</th><th>一个月</th><th>一年</th></tr></thead><tbody><tr><td>集合类型</td><td>400M</td><td>12G</td><td>144G</td></tr><tr><td>BitMaps</td><td>12.5M</td><td>375M</td><td>4.5G</td></tr></tbody></table><p><strong>缺点：</strong>但 Bitmaps 并不是万金油， 假如该网站每天的独立访问用户很少， 例如只有 10 万(大量的僵尸用户） ，那么两者的对比如下表所示， 很显然， 这时候使用 Bitmaps 就不太合适了， 因为基本上大部分位都是 0。</p><p>Set 和 Bitmaps 存储一天活跃用户对比（独立用户比较少) :</p><table><thead><tr><th>数据类型</th><th>每个用户id占用空间</th><th>需要存储的用户量</th><th>全部内存量</th></tr></thead><tbody><tr><td>集合类型</td><td>64位</td><td>100,000</td><td>64*10000&#x3D;800K</td></tr><tr><td>BitMaps</td><td>1位</td><td>100，000,000</td><td>1*100000000&#x3D;12.5M</td></tr></tbody></table><h2 id="Redis的事务"><a href="#Redis的事务" class="headerlink" title="Redis的事务"></a>Redis的事务</h2><p>Redis 事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。 </p><p>Redis 事务的主要作用就是<strong>串联多个命令</strong>防止别的命令插队。</p><p><strong>Redis</strong> <strong>事务三特性</strong> </p><p><strong>单独的隔离操作：</strong> </p><ul><li>事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会 被其他客户端发送来的命令请求所打断。</li></ul><p> <strong>没有隔离级别的概念：</strong> </p><ul><li>队列中的命令没有提交之前都不会实际被执行，因为事务提交前任何指令都 不会被实际执行 。</li></ul><p><strong>不保证原子性：</strong></p><ul><li>事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚。</li></ul><p><strong>Multi</strong>、<strong>xec</strong>、<strong>discard</strong></p><p>从输入 Multi 命令开始，输入的命令都会依次进入命令队列中，但不会执行，直到输入Exec 后，Redis 会将之前的命令队列中的命令依次执行。 </p><p>组队的过程中可以通过 discard 来放弃组队。</p><p><strong>解决超卖：</strong> <strong>利用乐观锁淘汰用户，解决超卖问题</strong>。</p><p><strong>连接超时：通过连接池解决节省每次连接 redis 服务带来的消耗，把连接好的实例反复利用。</strong></p><p><strong>已经秒光，可是还有库存：通过 lua 脚本解决争抢问题，实际上是 redis利用其单线程的特性，用任务队列的方式解决多任务并发问题。</strong></p><h2 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h2><h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><p>在指定的时间间隔内将内存中的数据集快照写入磁盘， 也就是行话讲的 Snapshot 快照，它恢复时是将快照文件直接读到内存里。</p><p><strong>优势</strong> </p><ul><li>适合大规模的数据恢复 。</li><li>对数据完整性和一致性要求不高更适合使用 。</li><li>节省磁盘空间 。</li><li>恢复速度快。</li></ul><p><strong>劣势</strong> </p><ul><li>Fork 的时候，内存中的数据被克隆了一份，大致 2 倍的膨胀性需要考虑 。</li><li>虽然 Redis 在 fork 时使用了<strong>写时拷贝技术</strong>,但是如果数据庞大时还是比较消 耗性能。 </li><li>在备份周期在一定间隔时间做一次备份，所以如果 Redis 意外 down 掉的话，就会丢失最后一次快照后的所有修改。</li></ul><h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><p>以<strong>日志</strong>的形式来记录每个写操作（增量保存），将 Redis 执行过的所有写指令记录下 来(<strong>读操作不记录</strong>)， <strong>只许追加文件但不可以改写文件</strong>，redis 启动之初会读取该文件重 新构建数据，换言之，redis 重启的话就根据日志文件的内容将写指令从前到后执行一 次以完成数据的恢复工作。</p><p><strong>优势</strong> </p><ul><li>备份机制更稳健，丢失数据概率更低。 </li><li>可读的日志文本，通过操作 AOF 稳健，可以处理误操作。</li></ul><p><strong>劣势</strong> </p><ul><li>比起 RDB 占用更多的磁盘空间。 </li><li>恢复备份速度要慢。 </li><li>每次读写都同步的话，有一定的性能压力。 </li><li>存在个别 Bug，造成恢复不能。</li></ul><h2 id="Redis主从复制"><a href="#Redis主从复制" class="headerlink" title="Redis主从复制"></a>Redis主从复制</h2><p>主机数据更新后根据配置和策略， 自动同步到备机的 master&#x2F;slaver 机制，<strong>Master</strong> <strong>以 写为主</strong>，<strong>Slave</strong> <strong>以读为主</strong> 。</p><p><strong>作用</strong></p><ul><li>读写分离，性能扩展 。</li><li>容灾快速恢复。</li></ul><h3 id="常用-3-招"><a href="#常用-3-招" class="headerlink" title="常用 3 招"></a><strong>常用</strong> <strong>3</strong> <strong>招</strong></h3><h4 id="一主二仆"><a href="#一主二仆" class="headerlink" title="一主二仆"></a>一主二仆</h4><p>一台主机，二台从机。</p><h4 id="薪火相传"><a href="#薪火相传" class="headerlink" title="薪火相传"></a>薪火相传</h4><p>上一个 Slave 可以是下一个 slave 的 Master，Slave 同样可以接收其他 slaves 的连接和同 步请求，那么该 slave 作为了链条中下一个的 master, 可以有效减轻 master 的写压力,去 中心化降低风险。 </p><h4 id="反客为主"><a href="#反客为主" class="headerlink" title="反客为主"></a>反客为主</h4><p>当一个 master 宕机后，后面的 slave 可以立刻升为 master，其后面的 slave 不用做任何 修改。用 slaveof no one 将从机变为主机。</p><h3 id="哨兵模式-sentinel"><a href="#哨兵模式-sentinel" class="headerlink" title="哨兵模式(sentinel)"></a>哨兵模式(sentinel)</h3><p><strong>反客为主的自动版</strong>，能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库。</p><h2 id="Redis应用问题"><a href="#Redis应用问题" class="headerlink" title="Redis应用问题"></a>Redis应用问题</h2><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p><strong>问题描述</strong> </p><p>key 对应的数据在数据源并不存在，每次针对此 key 的请求从缓存获取不到，请求 都会压到数据源，从而可能压垮数据源。比如用一个不存在的用户 id 获取用户信息， 不论缓存还是数据库都没有，若黑客利用此漏洞进行攻击可能压垮数据库。 </p><p><strong>解决方案</strong> </p><p>一个一定不存在缓存及查询不到的数据，由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。 </p><p>解决方案： </p><ol><li><strong>对空值缓存：</strong>如果一个查询返回的数据为空（不管是数据是否不存在），我们仍然把这个空结果（null）进行缓存，设置空结果的过期时间会很短，最 长不超过五分钟 </li><li><strong>设置可访问的名单（白名单）：</strong>使用 bitmaps 类型定义一个可以访问的名单，名单 id 作为 bitmaps 的偏移量，每次访问和 bitmap 里面的 id 进行比较，如果访问 id 不在 bitmaps 里面，进行拦截，不允许访问。 </li><li><strong>采用布隆过滤器：</strong>(布隆过滤器（Bloom Filter）是 1970 年由布隆提出的。它实际上是一个很长的二进制向量(位图)和一系列随机映射函数（哈希函数）。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。)将所有可能存在的数据哈希到一个足够大的 bitmaps 中，一个一定不存在的数据会被 这个 bitmaps 拦截掉，从而避免了对底层存储系统的查询压力。 </li><li><strong>进行实时监控：</strong>当发现 Redis 的命中率开始急速降低，需要排查访问对象和 访问的数据，和运维人员配合，可以设置黑名单限制服务 。</li></ol><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p><strong>解决方案</strong> </p><p>key 可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。这个时候，需要考虑一个问题：缓存被“击穿”的问题。 </p><p>解决问题： </p><ul><li><strong>预先设置热门数据：</strong>在 redis 高峰访问之前，把一些热门数据提前存入到redis 里面，加大这些热门数据 key 的时长 </li><li><strong>实时调整：</strong>现场监控哪些数据热门，实时调整 key 的过期时长 </li><li><strong>使用锁：</strong></li></ul><p>​      (1） 就是在缓存失效的时候（判断拿出来的值为空），不是立即去 load db。 </p><p>   （2）先使用缓存工具的某些带成功操作返回值的操作（比如 Redis 的 SETNX）去 set 一个 mutex key 。</p><p>   （3） 当操作返回成功时，再进行 load db 的操作，并回设缓存,最后删除 mutex key；。</p><p>   （4） 当操作返回失败，证明有线程在 load db，当前线程睡眠一段时间再重试整个 get 缓存的方法。</p><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p><strong>问题描述</strong> </p><p>key 对应的数据存在，但在 redis 中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端 DB 加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端 DB 压垮。 </p><p>缓存雪崩与缓存击穿的区别在于这里针对很多 key 缓存，前者则是某一个 key正常访问缓存失效瞬间 。</p><p><strong>解决方案</strong> </p><p>缓存失效时的雪崩效应对底层系统的冲击非常可怕！ </p><ul><li><strong>构建多级缓存架构：</strong>nginx 缓存 + redis 缓存 +其他缓存（ehcache 等） </li><li><strong>使用锁或队列：</strong>用加锁或者队列的方式保证来保证不会有大量的线程对数据库一次性进行 读写，从而避免失效时大量的并发请求落到底层存储系统上。不适用高并发情况。</li><li><strong>设置过期标志更新缓存：</strong>记录缓存数据是否过期（设置提前量），如果过期会触发通知另外的线程 在后台去更新实际 key 的缓存。 </li><li><strong>将缓存失效时间分散开：</strong>比如我们可以在原有的失效时间基础上增加一个随机值，比如 1-5 分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL</title>
      <link href="/2022/06/28/MySQL/"/>
      <url>/2022/06/28/MySQL/</url>
      
        <content type="html"><![CDATA[<h2 id="MySQL初级篇"><a href="#MySQL初级篇" class="headerlink" title="MySQL初级篇"></a>MySQL初级篇</h2><h3 id="SQL分类"><a href="#SQL分类" class="headerlink" title="SQL分类"></a>SQL分类</h3><ul><li><strong>DDL</strong>（<strong>Data Definition Languages、数据定义语言）</strong>，这些语句定义了不同的数据库、表、视图、索引等数据库对象，还可以用来创建、删除、修改数据库和数据表的结构。主要的语句关键字包括 CREATE 、 DROP 、 ALTER 等。</li><li><strong>DML****（</strong>Data Manipulation Language、数据操作语言）<strong>，用于添加、删除、更新和查询数据库记录，并检查数据完整性。主要的语句关键字包括 INSERT 、 DELETE 、 UPDATE 、 SELECT 等。</strong>SELECT**是SQL语言的基础，最为重要。</li><li><strong>DCL（Data Control Language、数据控制语言）</strong>，用于定义数据库、表、字段、用户的访问权限和安全级别。主要的语句关键字包括 GRANT 、 REVOKE 、 COMMIT 、 ROLLBACK 、 SAVEPOINT 等。因为查询语句使用的非常的频繁，所以很多人把查询语句单拎出来一类：DQL（数据查询语言）。还有单独将 COMMIT 、 ROLLBACK 取出来称为TCL （Transaction Control Language，事务控制语言）。</li></ul><h3 id="基本SELECT语句"><a href="#基本SELECT语句" class="headerlink" title="基本SELECT语句"></a>基本SELECT语句</h3><h4 id="列的别名"><a href="#列的别名" class="headerlink" title="列的别名"></a>列的别名</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name <span class="keyword">AS</span> name, commission_pct comm <span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure><h4 id="去除重复行"><a href="#去除重复行" class="headerlink" title="去除重复行"></a><strong>去除重复行</strong></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#在<span class="keyword">SELECT</span>语句中使用关键字<span class="keyword">DISTINCT</span>去除重复行</span><br><span class="line"><span class="keyword">SELECT</span> last_name &quot;Name&quot;, salary<span class="operator">*</span><span class="number">12</span> &quot;Annual Salary&quot; <span class="keyword">FROM</span> employees; <span class="keyword">SELECT</span> department_id <span class="keyword">FROM</span> employees; <span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> department_id <span class="keyword">FROM</span> employees;<span class="number">2.</span> <span class="keyword">DISTINCT</span> 其实是对后面所有列名的组合进行去重，你能看到最后的结果是 <span class="number">74</span> #<span class="keyword">DISTINCT</span> 其实是对后面所有列名的组合进行去重，你能看到最后的结果是 <span class="number">74</span> 条，因为这 <span class="number">74</span> 个部门id不同，都有 salary 这个属性值。如果你想要看都有哪些不同的部门（department_id），只需要写 <span class="keyword">DISTINCT</span> department_id 即可，后面不需要再加其他的列名了。</span><br></pre></td></tr></table></figure><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><h4 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h4><table><thead><tr><th>运算符</th><th>名称</th><th>作用</th><th>事列</th></tr></thead><tbody><tr><td>+</td><td>加法运算符</td><td>计算俩个表达式的和</td><td>SELECT 1+2</td></tr><tr><td>-</td><td>减法运算符</td><td>计算俩个表达式的差</td><td>SELECT 2-1</td></tr><tr><td>*</td><td>乘法运算符</td><td>计算俩个表达式的乘</td><td>SELECT 1*3</td></tr><tr><td>&#x2F;或DIV</td><td>除法运算符</td><td>计算俩个表达式的商</td><td>SELECT 1&#x2F;2</td></tr><tr><td>%或MOD</td><td>求余(模)运算符</td><td>计算俩个表达式的余数</td><td>SELECT 1%2</td></tr></tbody></table><h4 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h4><table><thead><tr><th>运算符</th><th>名称</th><th>作用</th><th>事列</th></tr></thead><tbody><tr><td>&#x3D;</td><td>等于运算符</td><td>判断俩个值、字符串、表达式是否相等</td><td>SELECT C FROM t WHERE A&#x3D;B</td></tr><tr><td>&lt;&#x3D;&gt;</td><td>安全等于运算符</td><td>安全的判断俩个值、字符串、表达式是否相等</td><td>SELECT C FROM t WHERE A&lt;&#x3D;&gt;B</td></tr><tr><td>&lt;&gt;(!&#x3D;)</td><td>不等于运算符</td><td>判断俩个值、字符串、表达式是否不相等</td><td>SELECT C FROM t WHERE A&lt;&gt;(!&#x3D;)B</td></tr><tr><td>&lt;</td><td>小于运算符</td><td>判断前面是否小于后面的</td><td>SELECT C FROM t WHERE A&lt;B</td></tr><tr><td>&gt;</td><td>大于运算符</td><td>判断前面是否大于后面的</td><td>SELECT C FROM t WHERE A&gt;B</td></tr><tr><td>&lt;&#x3D;</td><td>小于等于</td><td>判断前面是否小于等于后面的</td><td>SELECT C FROM t WHERE A&lt;&#x3D;B</td></tr><tr><td>&gt;&#x3D;</td><td>大于等于</td><td>判断前面是否大于等于后面的</td><td>SELECT C FROM t WHERE A&gt;&#x3D;B</td></tr></tbody></table><h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><table><thead><tr><th>运算符</th><th>名称</th><th>作用</th><th>事列</th></tr></thead><tbody><tr><td>NOT或！</td><td>逻辑非</td><td>取反</td><td>SELECT NOT 1</td></tr><tr><td>AND或&amp;&amp;</td><td>逻辑与</td><td>取与</td><td>SELECT A AND B</td></tr><tr><td>OR或||</td><td>逻辑或</td><td>或</td><td>SELECT  A||B</td></tr><tr><td>XOR</td><td>逻辑异或</td><td>异或</td><td>SELECT  A XOR B</td></tr></tbody></table><h4 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h4><table><thead><tr><th>运算符</th><th>名称</th><th>作用</th><th>事列</th></tr></thead><tbody><tr><td>&amp;</td><td>按位与</td><td>取与操作</td><td>SELECT A &amp; B</td></tr><tr><td>|</td><td>按位或</td><td>取或操作</td><td>SELECT A | B</td></tr><tr><td>^</td><td>按位异或</td><td>异或操作</td><td>SELECT A ^ B</td></tr><tr><td>~</td><td>按位取反</td><td>取反操作</td><td>SELECT ~A</td></tr><tr><td>&gt;&gt;</td><td>按位右移</td><td>相当于乘2</td><td>SELECT 2&gt;&gt;1</td></tr><tr><td>&lt;&lt;</td><td>按位左移</td><td>相当于除2</td><td>SELECT 2&lt;&lt;1</td></tr></tbody></table><h4 id="运算符的优先级"><a href="#运算符的优先级" class="headerlink" title="运算符的优先级"></a>运算符的优先级</h4><table><thead><tr><th>优先级</th><th>运算符</th></tr></thead><tbody><tr><td>1</td><td>&#x3D;(赋值)</td></tr><tr><td>2</td><td>OR（||），XOR</td></tr><tr><td>3</td><td>AND（&amp;&amp;）</td></tr><tr><td>4</td><td>NOT</td></tr><tr><td>5</td><td>BETWEEN、CASE、WHEN、THEN、ELSE</td></tr><tr><td>6</td><td>&#x3D; (比较运算符)、&lt;&#x3D;&gt;、&gt;&#x3D;、&lt;&#x3D;、&gt;、&lt;、!&#x3D;、IS、LIKE、IN、REGEXP</td></tr><tr><td>7</td><td>|</td></tr><tr><td>8</td><td>&amp;</td></tr><tr><td>9</td><td>&lt;&lt;、&gt;&gt;</td></tr><tr><td>10</td><td>-、+</td></tr><tr><td>11</td><td>*、&#x2F;</td></tr><tr><td>12</td><td>^</td></tr><tr><td>13</td><td>-、~</td></tr><tr><td>14</td><td>！</td></tr></tbody></table><h2 id="排序与分页"><a href="#排序与分页" class="headerlink" title="排序与分页"></a>排序与分页</h2><h3 id="排序规则"><a href="#排序规则" class="headerlink" title="排序规则"></a>排序规则</h3><p>使用 ORDER BY 子句排序</p><ul><li><strong>ASC（ascend）:升序</strong></li><li><strong>DESC（descend）:降序</strong></li></ul><p><strong>ORDER BY</strong> <strong>子句在SELECT语句的结尾。</strong></p><h3 id="单列排序"><a href="#单列排序" class="headerlink" title="单列排序"></a>单列排序</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name, job_id, department_id, hire_date <span class="keyword">FROM</span> employees <span class="keyword">ORDER</span> <span class="keyword">BY</span> hire_date ;</span><br></pre></td></tr></table></figure><h3 id="多列排序"><a href="#多列排序" class="headerlink" title="多列排序"></a>多列排序</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name, department_id, salary <span class="keyword">FROM</span> employees <span class="keyword">ORDER</span> <span class="keyword">BY</span> department_id, salary <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--前10条记录： SELECT * FROM 表名 LIMIT 0,10; 或者SELECT * FROM 表名 LIMIT 10;</span></span><br><span class="line"><span class="comment">--第11至20条记录： SELECT * FROM 表名 LIMIT 10,10;</span></span><br><span class="line"><span class="comment">--第21至30条记录： SELECT * FROM 表名 LIMIT 20,30;</span></span><br></pre></td></tr></table></figure><h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#中图：内连接 A∩B</span><br><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,department_name <span class="keyword">FROM</span> employees e <span class="keyword">JOIN</span> departments d <span class="keyword">ON</span> e.`department_id` <span class="operator">=</span> d.`department_id`;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#左上图：左外连接 </span><br><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,department_name <span class="keyword">FROM</span> employees e <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> departments d <span class="keyword">ON</span> e.`department_id` <span class="operator">=</span> d.`department_id`;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#右上图：右外连接 </span><br><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,department_name <span class="keyword">FROM</span> employees e <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> departments d <span class="keyword">ON</span> e.`department_id` <span class="operator">=</span> d.`department_id`;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#左中图：A <span class="operator">-</span> A∩B </span><br><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,department_name <span class="keyword">FROM</span> employees e <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> departments d <span class="keyword">ON</span> e.`department_id` <span class="operator">=</span> d.`department_id` <span class="keyword">WHERE</span> d.`department_id` <span class="keyword">IS</span> <span class="keyword">NULL</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#右中图：B<span class="operator">-</span>A∩B </span><br><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,department_name <span class="keyword">FROM</span> employees e <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> departments d <span class="keyword">ON</span> e.`department_id` <span class="operator">=</span> d.`department_id` <span class="keyword">WHERE</span> e.`department_id` <span class="keyword">IS</span> <span class="keyword">NULL</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#右下图 #左中图 <span class="operator">+</span> 右中图 A ∪B<span class="operator">-</span> A∩B 或者 (A <span class="operator">-</span> A∩B) ∪ （B <span class="operator">-</span> A∩B） </span><br><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,department_name <span class="keyword">FROM</span> employees e <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> departments d <span class="keyword">ON</span> e.`department_id` <span class="operator">=</span> d.`department_id` <span class="keyword">WHERE</span> d.`department_id` <span class="keyword">IS</span> <span class="keyword">NULL</span> <span class="keyword">UNION</span> <span class="keyword">ALL</span> <span class="keyword">SELECT</span> employee_id,last_name,department_name <span class="keyword">FROM</span> employees e <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> departments d <span class="keyword">ON</span> e.`department_id` <span class="operator">=</span> d.`department_id` <span class="keyword">WHERE</span> e.`department_id` <span class="keyword">IS</span> <span class="keyword">NULL</span></span><br></pre></td></tr></table></figure><h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><p>问题：谁的工资比Abel高？</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#方式一： </span><br><span class="line"><span class="keyword">SELECT</span> salary <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> last_name <span class="operator">=</span> <span class="string">&#x27;Abel&#x27;</span>; </span><br><span class="line"><span class="keyword">SELECT</span> last_name,salary <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> salary <span class="operator">&gt;</span> <span class="number">11000</span>; </span><br><span class="line">#方式二：自连接 <span class="keyword">SELECT</span> e2.last_name,e2.salary <span class="keyword">FROM</span> employees e1,employees e2 <span class="keyword">WHERE</span> e1.last_name <span class="operator">=</span> <span class="string">&#x27;Abel&#x27;</span> <span class="keyword">AND</span> e1.`salary` <span class="operator">&lt;</span> e2.`salary`</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#子查询</span><br><span class="line"><span class="keyword">SELECT</span> salary employees</span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="operator">&gt;</span> </span><br><span class="line">( <span class="keyword">SELECT</span> salary <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> last_name <span class="operator">=</span> <span class="string">&#x27;Abel&#x27;</span> );</span><br></pre></td></tr></table></figure><h2 id="单行函数、聚合函数"><a href="#单行函数、聚合函数" class="headerlink" title="单行函数、聚合函数"></a>单行函数、聚合函数</h2><h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h3><p><strong>AVG()</strong> </p><p><strong>SUM()</strong> </p><p><strong>MAX()</strong> </p><p><strong>MIN()</strong> </p><p><strong>COUNT()</strong></p><h3 id="WHERE和HAVING的对比"><a href="#WHERE和HAVING的对比" class="headerlink" title="WHERE和HAVING的对比"></a><strong>WHERE和HAVING</strong>的对比</h3><p><strong>区别1</strong>:<strong>WHERE可以直接使用表中的字段作为筛选条件，但不能使用分组中的计算函数作为筛选条件</strong>；<strong>HAVING 必须要与 GROUP BY 配合使用</strong>，可以把分组计算的函数和分组字段作为筛选条件。这决定了，在需要对数据进行分组统计的时候，HAVING 可以完成 WHERE 不能完成的任务。这是因为，在查询语法结构中，WHERE 在 GROUP BY 之前，所以无法对分组结果进行筛选。HAVING 在 GROUP BY 之后，可以使用分组字段和分组中的计算函数，对分组的结果集进行筛选，这个功能是 WHERE 无法完成的。另外，WHERE排除的记录不再包括在分组中。</p><p><strong>区别2</strong>：如果需要通过连接从关联表中获取需要的数据，WHERE是先筛选后连接，而<strong>HAVING 是先连接</strong>后筛选。 这一点，就决定了在关联查询中，WHERE 比 HAVING 更高效。因为 WHERE 可以先筛选，用一个筛选后的较小数据集和关联表进行连接，这样占用的资源比较少，执行效率也比较高。HAVING 则需要先把结果集准备好，也就是用未被筛选的数据集进行关联，然后对这个大的数据集进行筛选，这样占用的资源就比较多，执行效率也较低。</p><p><strong>开发中的选择：</strong></p><p>WHERE 和 HAVING 也不是互相排斥的，我们可以在一个查询里面同时使用 WHERE 和 HAVING。包含分组统计函数的条件用 HAVING，普通条件用 WHERE。这样，我们就既利用了 WHERE 条件的高效快速，又发挥了 HAVING 可以使用包含分组统计函数的查询条件的优点。当数据量特别大的时候，运行效率会有很大的差别。</p><h2 id="SQL执行流程"><a href="#SQL执行流程" class="headerlink" title="SQL执行流程"></a>SQL执行流程</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#方式<span class="number">1</span>：</span><br><span class="line"><span class="keyword">SELECT</span> ...,....,...</span><br><span class="line"><span class="keyword">FROM</span> ...,...,.... </span><br><span class="line"><span class="keyword">WHERE</span> 多表的连接条件 <span class="keyword">AND</span> 不包含组函数的过滤条件</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> ...,... </span><br><span class="line"><span class="keyword">HAVING</span> 包含组函数的过滤条件</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> ... <span class="keyword">ASC</span><span class="operator">/</span><span class="keyword">DESC</span></span><br><span class="line">LIMIT ...,...</span><br><span class="line">#方式<span class="number">2</span>： </span><br><span class="line"><span class="keyword">SELECT</span> ...,....,... </span><br><span class="line"><span class="keyword">FROM</span> ... </span><br><span class="line"><span class="keyword">JOIN</span> ... <span class="keyword">ON</span> 多表的连接条件 </span><br><span class="line"><span class="keyword">JOIN</span> ... <span class="keyword">ON</span> ... </span><br><span class="line"><span class="keyword">WHERE</span> 不包含组函数的过滤条件 </span><br><span class="line"><span class="keyword">AND</span><span class="operator">/</span><span class="keyword">OR</span> 不包含组函数的过滤条件 </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> ...,... </span><br><span class="line"><span class="keyword">HAVING</span> 包含组函数的过滤条件 </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> ... <span class="keyword">ASC</span><span class="operator">/</span><span class="keyword">DESC</span> </span><br><span class="line">LIMIT ...,... </span><br><span class="line">#其中： #（<span class="number">1</span>）<span class="keyword">from</span>：从哪些表中筛选 </span><br><span class="line">#（<span class="number">2</span>）<span class="keyword">on</span>：关联多表查询时，去除笛卡尔积 </span><br><span class="line">#（<span class="number">3</span>）<span class="keyword">where</span>：从表中筛选的条件 </span><br><span class="line">#（<span class="number">4</span>）<span class="keyword">group</span> <span class="keyword">by</span>：分组依据 </span><br><span class="line">#（<span class="number">5</span>）<span class="keyword">having</span>：在统计结果中再次筛选 </span><br><span class="line">#（<span class="number">6</span>）<span class="keyword">order</span> <span class="keyword">by</span>：排序 </span><br><span class="line">#（<span class="number">7</span>）limit：分页</span><br></pre></td></tr></table></figure><h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><p><strong>NOT NULL</strong> <strong>非空约束，规定某个字段不能为空</strong></p><p><strong>UNIQUE</strong> <strong>唯一约束</strong>，<strong>规定某个字段在整个表中是唯一的</strong></p><p>**PRIMARY KEY主键(非空且唯一)**约束</p><p><strong>FOREIGN KEY</strong> <strong>外键约束</strong></p><p><strong>CHECK</strong> <strong>检查约束</strong></p><p><strong>DEFAULT</strong> <strong>默认值约束</strong></p><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><h3 id="常见的数据库对象"><a href="#常见的数据库对象" class="headerlink" title="常见的数据库对象"></a>常见的数据库对象</h3><ul><li>表(TABLE) ：表是存储数据的逻辑单元，以行和列的形式存在，列就是字段，行就是记录</li><li>数据字典 ：就是系统表，存放数据库相关信息的表。系统表的数据通常由数据库系统维护，</li><li>程序员通常不应该修改，只可查看</li><li>约束(CONSTRAINT)：执行数据校验的规则，用于保证数据完整性的规则</li><li>视图(VIEW) ：一个或者多个数据表里的数据的逻辑显示，视图并不存储数据</li><li>索引(INDEX) ：用于提高查询性能，相当于书的目录</li><li>存储过程(PROCEDURE)：用于完成一次完整的业务处理，没有返回值，但可通过传出参数将多个值传给调用环境</li><li>存储函数(FUNCTION)：用于完成一次特定的计算，具有一个返回值</li><li>触发器(TRIGGER)：相当于一个事件监听器，当数据库发生特定事件后，触发器被触发，完成相应的处理</li></ul><h2 id="存储过程、函数"><a href="#存储过程、函数" class="headerlink" title="存储过程、函数"></a>存储过程、函数</h2><p><strong>好处</strong>： </p><p>1、简化操作，提高了sql语句的重用性，减少了开发程序员的压力。</p><p>2、减少操作过程中的失误，提高效率。</p><p>3、减少网络传输量（客户端不需要把所有的 SQL 语句通过网络发给服务器）</p><p>4、减少了 SQL 语句暴露在网上的风险，也提高了数据查询的安全性。</p><h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><p>MySQL从 5.0.2 版本开始支持触发器。MySQL的触发器和存储过程一样，都是嵌入到MySQL服务器的一段程序。触发器是由 事件来触发 某个操作，这些事件包括 INSERT 、 UPDATE 、 DELETE 事件。所谓事件就是指用户的动作或者触发某项行为。如果定义了触发程序，当数据库执行这些语句时候，就相当于事件发生了，就会 自动 激发触发器执行相应的操作。当对数据表中的数据执行插入、更新和删除操作，需要自动执行一些数据库逻辑时，可以使用触发器来实现。</p><h3 id="触发器的创建"><a href="#触发器的创建" class="headerlink" title="触发器的创建"></a>触发器的创建</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> 触发器名称 </span><br><span class="line">&#123;BEFORE<span class="operator">|</span>AFTER&#125; &#123;<span class="keyword">INSERT</span><span class="operator">|</span><span class="keyword">UPDATE</span><span class="operator">|</span><span class="keyword">DELETE</span>&#125; <span class="keyword">ON</span> 表名 </span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span> 触发器执行的语句块;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span> </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> before_insert BEFORE <span class="keyword">INSERT</span> <span class="keyword">ON</span> test_trigger </span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span> <span class="keyword">BEGIN</span><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_trigger_log (t_log) <span class="keyword">VALUES</span>(<span class="string">&#x27;before_insert&#x27;</span>); </span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span> </span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><p><strong>缺点</strong> </p><p><strong>1</strong>、触发器最大的一个问题就是可读性差。</p><p>因为触发器存储在数据库中，并且由事件驱动，这就意味着触发器有可能 不受应用层的控制 。这对系统维护是非常有挑战的。</p><p>比如，创建触发器用于修改会员储值操作。如果触发器中的操作出了问题，会导致会员储值金额更新失败。我用下面的代码演示一下：</p><p>结果显示，系统提示错误，字段“aa”不存在。这是因为，触发器中的数据插入操作多了一个字段，系统提示错误。可是，如果你不了解这个触发器，很可能会认为是更新语句本身的问题，或者是会员信息表的结构出了问题。说不定你还会给会员信息表添加一个叫“aa”的字段，试图解决这个问题，结果只能是白费力。</p><p><strong>2</strong>、相关数据的变更，可能会导致触发器出错。</p><p>特别是数据表结构的变更，都可能会导致触发出错，进而影响数据操作的正常运行。这些都会由于触</p><p>发器本身的隐蔽性，影响到应用中错误原因排查的效率。</p><h2 id="MySQL高级篇"><a href="#MySQL高级篇" class="headerlink" title="MySQL高级篇"></a>MySQL高级篇</h2><h3 id="MySQL逻辑架构图"><a href="#MySQL逻辑架构图" class="headerlink" title="MySQL逻辑架构图"></a>MySQL逻辑架构图</h3><img src="./images/mysql逻辑架构图.png" style="zoom:150%;"><p>简化为三层结构：</p><ol><li><p>连接层：客户端和服务器端建立连接，客户端发送 SQL 至服务器端；</p></li><li><p>SQL 层（服务层）：对 SQL 语句进行查询处理；与数据库文件的存储方式无关；</p></li><li><p>存储引擎层：与数据库文件打交道，负责数据的存储和读取。</p></li></ol><h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><h3 id="InnoDB-引擎：具备外键支持功能的事务存储引擎"><a href="#InnoDB-引擎：具备外键支持功能的事务存储引擎" class="headerlink" title="InnoDB 引擎：具备外键支持功能的事务存储引擎"></a><strong>InnoDB</strong> <strong>引擎：具备外键支持功能的事务存储引擎</strong></h3><p>MySQL从3.23.34a开始就包含InnoDB存储引擎。 大于等于5.5之后，默认采用InnoDB引擎 。 </p><p>InnoDB是MySQL的 默认事务型引擎 ，它被设计用来处理大量的短期(short-lived)事务。可以确保事务的完整提交(Commit)和回滚(Rollback)。</p><p>除了增加和查询外，还需要更新、删除操作，那么，应优先选择InnoDB存储引擎。</p><p><strong>除非有非常特别的原因需要使用其他的存储引擎，否则应该优先考虑InnoDB引擎。</strong></p><p>数据文件结构：（在《第02章_MySQL数据目录》章节已讲）</p><p>表名.frm 存储表结构（MySQL8.0时，合并在表名.ibd中）</p><p>表名.ibd 存储数据和索引</p><p>InnoDB是 为处理巨大数据量的最大性能设计 。</p><p>在以前的版本中，字典数据以元数据文件、非事务表等来存储。现在这些元数据文件被删除了。比如： .frm ， .par ， .trn ， .isl ， .db.opt 等都在MySQL8.0中不存在了。</p><p>对比MyISAM的存储引擎， InnoDB写的处理效率差一些 ，并且会占用更多的磁盘空间以保存数据和索引。</p><p>MyISAM只缓存索引，不缓存真实数据；InnoDB不仅缓存索引还要缓存真实数据， 对内存要求较 高 ，而且内存大小对性能有决定性的影响。</p><h3 id="MyISAM-引擎：主要的非事务处理存储引擎"><a href="#MyISAM-引擎：主要的非事务处理存储引擎" class="headerlink" title="MyISAM 引擎：主要的非事务处理存储引擎"></a><strong>MyISAM</strong> <strong>引擎：主要的非事务处理存储引擎</strong></h3><p>MyISAM提供了大量的特性，包括全文索引、压缩、空间函数(GIS)等，但MyISAM 不支持事务、行级 锁、外键 ，有一个毫无疑问的缺陷就是 崩溃后无法安全恢复 。 5.5之前默认的存储引擎优势是访问的 速度快 ，对事务完整性没有要求或者以SELECT、INSERT为主的应用</p><p>针对数据统计有额外的常数存储。故而 count(*) 的查询效率很高数据文件结构：</p><p>表名.frm 存储表结构</p><p>表名.MYD 存储数据 (MYData)</p><p>表名.MYI 存储索引 (MYIndex)</p><p>应用场景：只读应用或者以读为主的业务</p><table><thead><tr><th>区别</th><th>MyISAM</th><th>InnoDB</th></tr></thead><tbody><tr><td>构造上的区别</td><td>myisam在磁盘上存储上有三个文件.frm(存储表定义) .myd（存储表数据） .myi（存储表索引）；</td><td>innodb磁盘上存储的是表空间数据文件和日志文件，innodb表大小只受限于操作系统大小。</td></tr><tr><td>事务处理</td><td>不提供事务</td><td>提供事务</td></tr><tr><td>SELECT、UPDATE、INSERT、DELET</td><td>如果大量执行SELECT，MyISAM是好的选择</td><td>如果需要有UPDATE、INSERT、DELETE较多情况，InnoDB是好的选择</td></tr><tr><td>锁</td><td>表锁（不支持<a href="https://blog.csdn.net/qq_15127715/article/details/117613830?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165683621016781683912795%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=165683621016781683912795&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-117613830-null-null.142%5Ev30%5Econtrol,185%5Ev2%5Econtrol&utm_term=%E9%AB%98%E5%B9%B6%E5%8F%91&spm=1018.2226.3001.4187">高并发</a>，以读为主）</td><td>innodb支持行锁（共享锁，排它锁，意向锁），粒度更小</td></tr><tr><td>索引</td><td>聚簇索引、非聚簇索引</td><td>非聚簇索引</td></tr></tbody></table><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="索引概述"><a href="#索引概述" class="headerlink" title="索引概述"></a><strong>索引概述</strong></h3><p>MySQL官方对索引的定义为：<strong>索引（Index）是帮助MySQL高效获取数据的数据结构</strong>。</p><p><strong>索引的本质：</strong>索引是数据结构。你可以简单理解为“排好序的快速查找数据结构”，满足特定查找算法。这些数据结构以某种方式指向数据， 这样就可以在这些数据结构的基础上实现 高级查找算法 。</p><p><strong>索引的分类</strong> ：</p><p>MySQL的索引包括普通索引、唯一性索引、全文索引、单列索引、多列索引和空间索引等。</p><p>从 功能逻辑 上说，索引主要有 4 种，分别是普通索引、唯一索引、主键索引、全文索引。</p><p>按照 物理实现方式 ，索引可以分为 2 种：聚簇索引和非聚簇索引。</p><p>按照 作用字段个数 进行划分，分成单列索引和联合索引。</p><p><strong>1.</strong> <strong>普通索引</strong></p><p><strong>2.</strong> <strong>唯一性索引</strong></p><p><strong>3.</strong> <strong>主键索引</strong></p><p><strong>4.</strong> <strong>单列索引</strong></p><p><strong>5.</strong> <strong>多列(组合、联合)索引</strong></p><p><strong>6.</strong> <strong>全文索引</strong> </p><p><strong>优点</strong> ：</p><ol><li>类似大学图书馆建书目索引，提高数据检索的效率，降低数据库的IO成本 ，这也是创建索引最主要的原因。 </li><li>通过创建唯一索引，可以保证数据库表中每一行 数据的唯一性 。 </li><li>在实现数据的参考完整性方面，可以 加速表和表之间的连接。 换句话说，对于有依赖关系的子表和父表联合查询时，可以提高查询速度。 </li><li>在使用分组和排序子句进行数据查询时，可以显著减少查询中分组和排序的时 间 ，降低了CPU的消耗。</li></ol><p><strong>缺点</strong>：</p><ol><li>创建索引和维护索引要 耗费时间 ，并且随着数据量的增加，所耗费的时间也会增加。 </li><li>索引需要占磁盘空间 ，除了数据表占数据空间之外，每一个索引还要占一定的物理空间， 存储在磁盘上 ，如果有大量的索引，索引文件就可能比数据文件更快达到最大文件尺寸。 </li><li>虽然索引大大提高了查询速度，同时却会 降低更新表的速度 。当对表中的数据进行增加、删除和修改的时候，索引也要动态地维护，这样就降低了数据的维护速度。</li></ol><p>因此，选择使用索引时，需要综合考虑索引的优点和缺点。</p><h3 id="常见索引概念"><a href="#常见索引概念" class="headerlink" title="常见索引概念"></a><strong>常见索引概念</strong></h3><p>索引按照物理实现方式，索引可以分为 2 种：聚簇（聚集）和非聚簇（非聚集）索引。我们也把非聚集</p><p>索引称为二级索引或者辅助索引。</p><h4 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a><strong>聚簇索引</strong></h4><p><strong>特点：</strong></p><ol><li>使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义：</li></ol><ul><li>页内 的记录是按照主键的大小顺序排成一个单向链表 。</li><li>各个存放用户记录的页 也是根据页中用户记录的主键大小顺序排成一个 双向链表 。</li><li>存放目录项记录的页 分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个 双向链表 。</li></ul><ol start="2"><li>B+树的 叶子节点 存储的是完整的用户记录。</li></ol><p>所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。</p><p><strong>优点：</strong></p><ul><li>数据访问更快 ，因为聚簇索引将索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比非聚簇索引更快。</li><li>聚簇索引对于主键的 <strong>排序查找</strong> 和 <strong>范围查找</strong> 速度非常快</li><li>按照聚簇索引排列顺序，查询显示一定范围数据的时候，由于数据都是紧密相连，数据库不用从多个数据块中提取数据，所以 节省了大量的io操作 。</li></ul><p><strong>缺点：</strong></p><ul><li>插入速度严重依赖于插入顺序 ，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个<strong>自增的ID列为主键</strong>。</li><li>更新主键的代价很高 ，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义<strong>主键为不可更新。</strong></li><li>二级索引访问需要两次索引查找 ，第一次找到主键值，第二次根据主键值找到行数据。</li></ul><h4 id="二级索引（辅助索引、非聚簇索引）"><a href="#二级索引（辅助索引、非聚簇索引）" class="headerlink" title="二级索引（辅助索引、非聚簇索引）"></a>二级索引（辅助索引、非聚簇索引）</h4><p>概念：<strong>回表</strong> 我们根据这个以c2列大小排序的B+树只能确定我们要查找记录的主键值，所以如果我们想根据c2列的值查找到完整的用户记录的话，仍然需要到 聚簇索引 中再查一遍，这个过程称为 回表 。也就是根据c2列的值查询一条完整的用户记录需要使用到 2 棵B+树！</p><h4 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a><strong>联合索引</strong></h4><p>我们也可以同时以多个列的大小作为排序规则，也就是同时为多个列建立索引，比方说我们想让B+树按照 c2和c3列 的大小进行排序，这个包含两层含义：</p><ul><li>先把各个记录和页按照c2列进行排序。</li><li>在记录的c2列相同的情况下，采用c3列进行排序。</li></ul><p>注意一点，以c2和c3列的大小为排序规则建立的B+树称为 联合索引 ，本质上也是一个二级索引。它的意思与分别为c2和c3列分别建立索引的表述是不同的，不同点如下：</p><ul><li>建立 联合索引 只会建立如上图一样的1棵B+树。</li><li>为c2和c3列分别建立索引会分别以c2和c3列的大小为排序规则建立2棵B+树。</li></ul><h3 id="各种数据结构做索引比较"><a href="#各种数据结构做索引比较" class="headerlink" title="各种数据结构做索引比较"></a>各种数据结构做索引比较</h3><table><thead><tr><th>数据结构名称</th><th>查询速度</th><th>局限</th></tr></thead><tbody><tr><td>B+树</td><td>O(logN)</td><td>InnoDB和MyISAM默认存储数据结构</td></tr><tr><td>B树</td><td>速度相对于B+树不稳定</td><td>相对于B+树只能通过中序遍历(非叶子结点)、同样磁盘页存储子树少</td></tr><tr><td>Hash</td><td>O(1)</td><td>不能做范围查询、会有hash冲突、不能排序、不支持联合索引最左侧原则</td></tr><tr><td>AVL(平衡二叉树)</td><td>O(logN)</td><td>树的深度较高</td></tr></tbody></table><h2 id="索引优化与查询优化"><a href="#索引优化与查询优化" class="headerlink" title="索引优化与查询优化"></a><strong>索引优化与查询优化</strong></h2><h3 id="慢查询日志分析工具：mysqldumpslow"><a href="#慢查询日志分析工具：mysqldumpslow" class="headerlink" title="慢查询日志分析工具：mysqldumpslow"></a>慢查询日志分析工具：mysqldumpslow</h3><p>在生产环境中，如果要手工分析日志，查找、分析SQL，显然是个体力活，MySQL提供了日志分析工具mysqldumpslow 。</p><p>查看mysqldumpslow的帮助信息mysqldumpslow 命令的具体参数如下：</p><p>-a: 不将数字抽象成N，字符串抽象成S </p><p>-s: 是表示按照何种方式排序：</p><p>c: 访问次数</p><p>l: 锁定时间</p><p>r: 返回记录</p><p><strong>t:</strong> <strong>查询时间</strong></p><p>al:平均锁定时间</p><p>ar:平均返回记录数</p><p>at:平均查询时间 （默认方式）</p><p>ac:平均查询次数</p><p>-t: 即为返回前面多少条的数据；</p><p>6 rows in set (2.39 sec) </p><p>show status like ‘slow_queries’; </p><p>mysqldumpslow –help</p><h3 id="分析查询语句：EXPLAIN"><a href="#分析查询语句：EXPLAIN" class="headerlink" title="分析查询语句：EXPLAIN"></a>分析查询语句：EXPLAIN</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1;</span><br></pre></td></tr></table></figure><table><thead><tr><th>列名</th><th>描述</th></tr></thead><tbody><tr><td>id</td><td>在一个大的查询语句中每个SELECT关键字都对应一个 唯一的id</td></tr><tr><td>select_type</td><td>SELECT关键字对应的那个查询的类型</td></tr><tr><td>table</td><td>表名</td></tr><tr><td>partitions</td><td>匹配的分区信息</td></tr><tr><td>type<strong>☆</strong></td><td>针对单表的访问方法</td></tr><tr><td>possible_keys</td><td>可能用到的索引</td></tr><tr><td>key</td><td>实际上使用的索引</td></tr><tr><td>key_len<strong>☆</strong></td><td>实际使用到的索引长度</td></tr><tr><td>ref</td><td>当使用索引列等值查询时，与索引列进行等值匹配的对象信息</td></tr><tr><td>rows <strong>☆</strong></td><td>预估的需要读取的记录条数</td></tr><tr><td>filtered</td><td>某个表经过搜索条件过滤后剩余记录条数的百分比</td></tr><tr><td>Extra <strong>☆</strong></td><td>一些额外的信息</td></tr></tbody></table><p><strong>id:</strong></p><ul><li><strong>id如果相同，可以认为是一组，从上往下顺序执行</strong></li><li><strong>在所有组中，id值越大，优先级越高，越先执行</strong></li><li><strong>关注点：id号每个号码，表示一趟独立的查询, 一个sql的查询趟数越少越好</strong></li></ul><p><strong>type <strong>☆</strong>:</strong></p><p><strong>结果值从最好到最坏依次是：</strong> <strong>system &gt; const &gt; eq_ref &gt; ref</strong> <strong>&gt; fulltext &gt; ref_or_null &gt; index_merge &gt;</strong> </p><p><strong>unique_subquery &gt; index_subquery &gt;</strong> <strong>range &gt; index &gt; ALL</strong> 其中比较重要的几个提取出来。SQL性能优化的目标：至少要达到 <strong>range</strong> <strong>级别，要求是</strong> <strong>ref</strong> <strong>级别</strong>，最好是<strong>consts</strong>级别。（阿里巴巴开发手册要求）</p><h2 id="数据库设计规范"><a href="#数据库设计规范" class="headerlink" title="数据库设计规范"></a>数据库设计规范</h2><h3 id="第一范式"><a href="#第一范式" class="headerlink" title="第一范式"></a>第一范式</h3><p>确保表中每一列数据的原子性，不可再分！</p><h3 id="第二范式"><a href="#第二范式" class="headerlink" title="第二范式"></a>第二范式</h3><p>在满足第一范式的基础上，确保列数据要跟主键关联，不能出现部分依赖。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">成绩表 （学号，课程号，成绩）关系中，（学号，课程号）可以决定成绩，但是学号不能决定成绩，课</span><br><span class="line">程号也不能决定成绩，所以“（学号，课程号）→成绩”就是 完全依赖关系 。</span><br></pre></td></tr></table></figure><h3 id="第三范式"><a href="#第三范式" class="headerlink" title="第三范式"></a>第三范式</h3><p>再满足第二范式的基础上，保证每一列数据都要跟主键直接关联，不能出现传递依赖。</p><table><thead><tr><th>字段名称</th><th>字段类型</th><th>是否为主键</th><th>说明</th></tr></thead><tbody><tr><td>id</td><td>INT</td><td>是</td><td>商品主键id （主键）</td></tr><tr><td>category_id</td><td>INT</td><td>否</td><td>商品类别id</td></tr><tr><td>category_name</td><td>VARCHAR(30)</td><td>否</td><td>商品类别名称</td></tr><tr><td>goods_name</td><td>VARCHAR(30)</td><td>否</td><td>商品名称</td></tr><tr><td>price</td><td>DECIMAL(10,2)</td><td>否</td><td>商品价格</td></tr></tbody></table><p><strong>商品类别名称依赖于商品类别编号，不符合第三范式</strong>。</p><p><strong>商品类别表</strong></p><table><thead><tr><th>字段名称</th><th>字段类型</th><th>是否为主键</th><th>说明</th></tr></thead><tbody><tr><td>id</td><td>INT</td><td>是</td><td>商品主键id （主键）</td></tr><tr><td>category_name</td><td>VARCHAR(30)</td><td>否</td><td>商品类别名称</td></tr></tbody></table><p><strong>商品表</strong></p><table><thead><tr><th>字段名称</th><th>字段类型</th><th>是否为主键</th><th>说明</th></tr></thead><tbody><tr><td>id</td><td>INT</td><td>是</td><td>商品主键id （主键）</td></tr><tr><td>category_id</td><td>VARCHAR(30)</td><td>否</td><td>商品类别id</td></tr><tr><td>goods_name</td><td>VARCHAR(30)</td><td>否</td><td>商品名称</td></tr><tr><td>price</td><td>DECIMAL(10,2)</td><td>否</td><td>商品价格</td></tr></tbody></table><h2 id="INNODB"><a href="#INNODB" class="headerlink" title="INNODB"></a>INNODB</h2><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><table><thead><tr><th>隔离级别</th><th>脏写</th><th>脏读</th><th>不可重复读</th><th>序列化读</th></tr></thead><tbody><tr><td>READ UNCOMMITED</td><td>NO</td><td>YES</td><td>YES</td><td>YES</td></tr><tr><td>READ COMMITED</td><td>NO</td><td>NO</td><td>YES</td><td>YES</td></tr><tr><td>REPEATABLE READ</td><td>NO</td><td>NO</td><td>NO</td><td>NO</td></tr><tr><td>SERIALIZEABLE</td><td>NO</td><td>NO</td><td>NO</td><td>NO</td></tr></tbody></table><h3 id="ACID属性"><a href="#ACID属性" class="headerlink" title="ACID属性"></a><strong>ACID属性</strong></h3><p>  事务是由一组SQL语句组成的逻辑处理单元，事务具有4属性，通常称为事务的ACID属性。</p><ul><li>原子性（Actomicity）：事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行。</li><li>一致性（Consistent）：在事务开始和完成时，数据都必须保持一致状态。这意味着所有相关的数据规则都必须应用于事务的修改，以操持完整性；事务结束时，所有的内部数据结构（如B树索引或双向链表）也都必须是正确的。</li><li>隔离性（Isolation）：数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的“独立”环境执行。这意味着事务处理过程中的中间状态对外部是不可见的，反之亦然。</li><li>持久性（Durable）：事务完成之后，它对于数据的修改是永久性的，即使出现系统故障也能够保持。</li></ul><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="对数据的操作类型划分"><a href="#对数据的操作类型划分" class="headerlink" title="对数据的操作类型划分"></a>对数据的操作类型划分</h3><table><thead><tr><th></th><th align="center">表现</th><th>位置</th></tr></thead><tbody><tr><td>读锁&#x2F;共享锁(S)</td><td align="center">针对同一份数据，多个事务的读操作可以同时进行而不会互相影响，相互不阻塞的。</td><td>对于InnoDB，可以加在表上，也可以加在行上</td></tr><tr><td>写锁&#x2F;排他锁(X)</td><td align="center">当前写操作没有完成前，它会阻断其他写锁和读锁。</td><td>对于InnoDB，可以加在表上，也可以加在行上</td></tr></tbody></table><h3 id="对数据操作粒度划分"><a href="#对数据操作粒度划分" class="headerlink" title="对数据操作粒度划分"></a>对数据操作粒度划分</h3><table><thead><tr><th>名称</th><th align="center">表现</th></tr></thead><tbody><tr><td>表锁</td><td align="center">开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。</td></tr><tr><td>InnoDB行锁（1记录锁、2间隙锁、3、临建锁、4插入意向锁）</td><td align="center">开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</td></tr><tr><td>页面锁</td><td align="center">开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般</td></tr></tbody></table><h3 id="对锁的态度"><a href="#对锁的态度" class="headerlink" title="对锁的态度"></a>对锁的态度</h3><table><thead><tr><th>名称</th><th align="center">表现</th><th>位置</th></tr></thead><tbody><tr><td>悲观锁</td><td align="center">共享资源每次只给个线程使用，其他线程阻塞，用完再把资源转让给其他线程</td><td>写多读少</td></tr><tr><td>乐观锁</td><td align="center">不用每次都对数据上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据</td><td>读多写少</td></tr></tbody></table><h3 id="按加锁的方式划分"><a href="#按加锁的方式划分" class="headerlink" title="按加锁的方式划分"></a>按加锁的方式划分</h3><table><thead><tr><th>名称</th><th align="center">表现</th></tr></thead><tbody><tr><td>隐式锁</td><td align="center">MySQL 的 InnoDB 存储引擎采用两段锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这被称为隐式锁定</td></tr><tr><td>显示锁</td><td align="center">用特定语句进行显示锁定SELECT … LOCK In SHARE MODE;(共享锁)SELECT … FOR UPDATE;(排他锁)事务完成提交自动释放锁</td></tr></tbody></table><p><strong>两段锁协议</strong>：加锁和解锁分为两个阶段进行，可串行化调度是指通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同，串行执行的事务互不干扰，不会出现并发一致性问题。</p><h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>MVCC （Multiversion Concurrency Control），多版本并发控制。顾名思义，MVCC 是通过数据行的多个版本管理来实现数据库的 并发控制 。这项技术使得在InnoDB的事务隔离级别下执行 一致性读 操作有了保证。换言之，就是为了查询一些正在被另一个事务更新的行，并且可以看到它们被更新之前的值，这样在做查询的时候就不用等待另一个事务释放锁。</p><h2 id="数据库日志"><a href="#数据库日志" class="headerlink" title="数据库日志"></a>数据库日志</h2><ul><li><strong>慢查询日志：</strong>记录所有执行时间超过long_query_time的所有查询，方便我们对查询进行优化。</li><li><strong>通用查询日志：</strong>记录所有连接的起始时间和终止时间，以及连接发送给数据库服务器的所有指令，对我们复原操作的实际场景、发现问题，甚至是对数据库操作的审计都有很大的帮助。</li><li><strong>错误日志：</strong>记录MySQL服务的启动、运行或停止MySQL服务时出现的问题，方便我们了解服务器的状态，从而对服务器进行维护。</li><li><strong>二进制日志：</strong>记录所有更改数据的语句，可以用于主从服务器之间的数据同步，以及服务器遇到故障时数据的无损失恢复。</li><li><strong>中继日志：</strong>用于主从服务器架构中，从服务器用来存放主服务器二进制日志内容的一个中间文件。从服务器通过读取中继日志的内容，来同步主服务器上的操作。</li><li><strong>数据定义语句日志：</strong>记录数据定义语句执行的元数据操作。</li></ul><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><h3 id="由来"><a href="#由来" class="headerlink" title="由来"></a>由来</h3><p>如果我们的目的在于提升数据库高并发访问的效率，那么首先考虑的是如何  <strong>1、优化SQL和索引</strong> ，这种方式简单有效；其次才是采用 <strong>2、缓存的策略</strong> ，比如使用 Redis将热点数据保存在内存数据库中，提升读取的效率；最后才是对数据库采用 <strong>3、主从架构</strong> ，进行读写分离。</p><h3 id="主从复制的作用"><a href="#主从复制的作用" class="headerlink" title="主从复制的作用"></a>主从复制的作用</h3><ul><li><p><strong>读写分离。</strong></p></li><li><p><strong>数据备份。</strong></p></li><li><p><strong>是具有高可用性。</strong></p><h3 id="主从复制原理"><a href="#主从复制原理" class="headerlink" title="主从复制原理"></a>主从复制原理</h3></li></ul><h2 id="数据库备份及恢复"><a href="#数据库备份及恢复" class="headerlink" title="数据库备份及恢复"></a>数据库备份及恢复</h2><p><strong>物理备份</strong>：备份数据文件，转储数据库物理文件到某一目录。物理备份恢复速度比较快，但占用空间比较大，MySQL中可以xtrabackup 工具来进行物理备份。</p><p><strong>逻辑备份</strong>：对数据库对象利用工具进行导出工作，汇总入备份文件内。逻辑备份恢复速度慢，但占用空间小，更灵活。MySQL 中常用的逻辑备份工具为 mysqldump 。逻辑备份就是 备份sql语句 ，在恢复的时候执行备份的sql语句实现数据库数据的重现。 </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud</title>
      <link href="/2022/06/28/SpringCloud/"/>
      <url>/2022/06/28/SpringCloud/</url>
      
        <content type="html"><![CDATA[<h3 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Springboot</title>
      <link href="/2022/06/28/Springboot/"/>
      <url>/2022/06/28/Springboot/</url>
      
        <content type="html"><![CDATA[<h3 id="Springboot"><a href="#Springboot" class="headerlink" title="Springboot"></a>Springboot</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SSM</title>
      <link href="/2022/06/28/SSM/"/>
      <url>/2022/06/28/SSM/</url>
      
        <content type="html"><![CDATA[<h3 id="Spring-SpringMVC-Mybatis"><a href="#Spring-SpringMVC-Mybatis" class="headerlink" title="Spring+SpringMVC+Mybatis"></a>Spring+SpringMVC+Mybatis</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaWeb</title>
      <link href="/2022/06/28/JavaWeb/"/>
      <url>/2022/06/28/JavaWeb/</url>
      
        <content type="html"><![CDATA[<h3 id="javaWeb"><a href="#javaWeb" class="headerlink" title="javaWeb"></a>javaWeb</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java高级</title>
      <link href="/2022/06/28/Java%E9%AB%98%E7%BA%A7/"/>
      <url>/2022/06/28/Java%E9%AB%98%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<h3 id="java高级篇"><a href="#java高级篇" class="headerlink" title="java高级篇"></a>java高级篇</h3><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p><a href="https://blog.csdn.net/weixin_46594796/article/details/118082268">Java反射</a></p><h3 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h3><p><a href="https://blog.csdn.net/ningmengshuxiawo/article/details/119102854">IO流</a></p><h3 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h3><p><a href="https://blog.csdn.net/weixin_44491927/article/details/108560692">JUC多线程</a></p><h3 id="java锁"><a href="#java锁" class="headerlink" title="java锁"></a>java锁</h3><table><thead><tr><th>锁名称</th><th>应用</th><th>表现</th></tr></thead><tbody><tr><td>悲观锁</td><td>synchronized、vector、hastable</td><td>读少写多</td></tr><tr><td>乐观锁</td><td>CAS</td><td>读多写少</td></tr><tr><td>自旋锁</td><td>CAS</td><td>避免线程切换的开销，耗费处理器资源</td></tr><tr><td>可重入锁</td><td>synchornized、Reentrantlock、Lock</td><td>避免死锁</td></tr><tr><td>读写锁</td><td>ReentrantReadWriterlock</td><td>分读锁、写锁</td></tr><tr><td>公平锁</td><td>Reentrantlock(true)</td><td>按照FIFO的原则从队列中拿到线程，然后占有锁</td></tr><tr><td>非公平锁</td><td>Reentrantlock(false)、synchornized</td><td>性能高于公平锁，会导致线程饥饿</td></tr><tr><td>独占锁</td><td>synchornized、vector、ReentrantReadWriterlock中写锁</td><td>是一种设计思想</td></tr><tr><td>共享锁</td><td>ReentrantReadWriterlock中读锁</td><td>是一种设计思想</td></tr><tr><td>偏向锁</td><td>锁优化</td><td>偏向于第一个获得它的线程</td></tr><tr><td>轻量级锁</td><td>锁优化</td><td>在无竞争的情况下使用CAS操作去消除同步使用的互斥量</td></tr><tr><td>重量级锁</td><td>synchornized</td><td>通过对象内部的一个监视器锁（monitor）来实现，monitor本身依赖Mutex Lock</td></tr><tr><td>分段锁</td><td>concurrentHashMap</td><td>是一个 Segment 数组， Segment 通过继承 ReentrantLock 来进行加锁</td></tr><tr><td>互斥锁</td><td>synchornized</td><td>表示并发执行的多个线程，在同一时间内只允许一个线程访问 共享数据</td></tr><tr><td>同步锁</td><td>synchornized</td><td>表示并发执行的多个线程，在同一时间内只允许一个线程访问 共享数据</td></tr><tr><td>死锁</td><td>相互请求对方资源</td><td>A线程有对象锁1想要对象锁2才能执行处于等待状态，B线程想要锁1，二者死等</td></tr><tr><td>锁粗化</td><td>锁优化</td><td>把加锁的范围扩展到整个操作序列的外部，加锁和解锁频率下降减少性能消耗</td></tr><tr><td>锁消除</td><td>锁优化</td><td>利用逃逸分析技术，把锁干掉</td></tr></tbody></table><h4 id="synchronized升级"><a href="#synchronized升级" class="headerlink" title="synchronized升级"></a>synchronized升级</h4><p> <strong>无锁态</strong><br>偏向锁位、锁标志位的值为：0 01，此时对象是没有做任何同步限制的，为什么会有这个状态在下面的偏向锁中会跟大家介绍。</p><p> <strong>偏向锁</strong><br>偏向锁位、锁标志位的值为：1 01。</p><p>有研究表明，其实在大部分场景都不会发生锁资源竞争，并且锁资源往往都是由一个线程获得的。如果这种情况下，同一个线程获取这个锁都需要进行一系列操作，比如说CAS自旋，那这个操作很明显是多余的。偏向锁就解决了这个问题。其核心思想就是：一个线程获取到了锁，那么锁就会进入偏向模式，当同一个线程再次请求该锁的时候，无需做任何同步，直接进行同步区域执行。这样就省去了大量有关锁申请的操作。所以，对于没有锁竞争的场合，偏向锁有很好的优化效果。</p><p>偏向锁加锁过程：</p><ol><li>访问Mark Word中偏向锁的标识是否设置成1，锁标志位是否为01，确认为可偏向状态。</li><li>如果为可偏向状态，则判断线程ID是否指向当前线程，如果是，进入步骤5，否则进入步骤3。</li><li>如果线程ID并未指向当前线程，则通过CAS操作竞争锁。如果竞争成功，则将Mark Word中线程ID设置为当前线程ID，然后执行5；如果竞争失败，执行4。</li><li>如果CAS获取偏向锁失败，则表示有竞争。当到达全局安全点（safepoint）时获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码。</li><li>执行同步代码。</li></ol><p>偏向锁的撤销在上述第四步骤中有提到。偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动去释放偏向锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态，撤销偏向锁后恢复到未锁定（标志位为“01”）或轻量级锁（标志位为“00”）的状态。</p><p>偏向锁的适用场景：</p><p>始终只有一个线程在执行同步块，在它没有执行完释放锁之前，没有其它线程去执行同步块，在锁无竞争的情况下使用，一旦有了竞争就升级为轻量级锁，升级为轻量级锁的时候需要撤销偏向锁。在有锁的竞争时，偏向锁会多做很多额外操作，尤其是撤销偏向锁的时候会导致进入安全点，安全点会导致stw，导致性能下降，这种情况下应当禁用。所以一般JVM并不是一开始就开启偏向锁的，而是有一定的延迟，这也就是为什么会有无锁态的原因。可以使用-XX:BiasedLockingStartupDelay&#x3D;0来关闭偏向锁的启动延迟, 也可以使用-XX:-UseBiasedLocking&#x3D;false来关闭偏向锁。偏向锁撤销导致的stw</p><p>通过加偏向锁的方式可以看到，对象中记录了获取到对象锁的线程ID，这就意味如果短时间同一个线程再次访问这个加锁的同步代码或方法时，该线程只需要对对象头Mark Word中去判断一下是否有偏向锁指向它的ID，有的话就继续执行逻辑了，没有的话，会CAS尝试获得锁，如果持有锁的线程在全局安全点检查时，不需要再使用该锁了则获取成功，程序继续执行，反之则获取锁失败，撤销偏向状态，升级为轻量级锁，即自旋锁。</p><p> <strong>轻量级锁（自旋锁）</strong></p><p>当有另外一个线程竞争获取这个锁时，由于该锁已经是偏向锁，当发现对象头 Mark Word 中的线程 ID 不是自己的线程 ID，销偏向锁状态，将锁对象markWord中62位修改成指向自己线程栈中Lock Record的指针（CAS抢）执行在用户态，消耗CPU的资源（自旋锁不适合锁定时间长的场景、等待线程特别多的场景），此时锁标志位为：00。</p><p>自旋策略<br>JVM 提供了一种自旋锁，可以通过自旋方式不断尝试获取锁，从而避免线程被挂起阻塞。这是基于大多数情况下，线程持有锁的时间都不会太长，毕竟线程被挂起阻塞可能会得不偿失。</p><p>自适应自旋锁</p><p>JDK 1.6引入了更加聪明的自旋锁，叫做自适应自旋锁。他的自旋次数是会变的，我用大白话来讲一下，就是线程如果上次自旋成功了，那么这次自旋的次数会更加多，因为虚拟机认为既然上次成功了，那么这次自旋也很有可能会再次成功。反之，如果某个锁很少有自旋成功，那么以后的自旋的次数会减少甚至省略掉自旋过程，以免浪费处理器资源。 大家现在觉得没这么low了吧。</p><p>轻量级锁的加锁过程：</p><p>在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝，官方称之为 Displaced Mark Word。<br>拷贝对象头中的Mark Word复制到锁记录中；<br>拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word中的62位更新为指向Lock Record的指针，并将Lock record里的owner指针指向object mark word。如果更新成功，则执行步骤4，否则执行步骤5。<br>如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，即表示此对象处于轻量级锁定状态。<br>如果这个更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行。此时为了提高获取锁的效率，线程会不断地循环去获取锁, 这个循环是有次数限制的, 如果在循环结束之前CAS操作成功, 那么线程就获取到锁, 如果循环结束依然获取不到锁, 则获取锁失败, 对象的MarkWord中的记录会被修改为指向互斥量（重量级锁）的指针，锁标志的状态值变为10，线程被挂起，后面来的线程也会直接被挂起。</p><p>轻量级锁的释放</p><p>释放锁线程视角：由轻量锁切换到重量锁，是发生在轻量锁释放锁的期间，之前在获取锁的时候它拷贝了锁对象头的markword，在释放锁的时候如果它发现在它持有锁的期间有其他线程来尝试获取锁了，并且该线程对markword做了修改，两者比对发现不一致，则切换到重量锁。因为重量级锁被修改了，所有display mark word和原来的markword不一样了。<br>怎么补救，就是进入mutex前，compare一下obj的markword状态。确认该markword是否被其他线程持有。此时如果线程已经释放了markword，那么通过CAS后就可以直接进入线程，无需进入mutex，就这个作用。</p><p>尝试获取锁线程视角：如果线程尝试获取锁的时候，轻量锁正被其他线程占有，那么它就会修改markword，修改重量级锁，表示该进入重量锁了。</p><p>从 JDK1.7 开始，自旋锁默认启用，自旋次数由 JVM 设置决定，这里我不建议设置的重试次数过多，因为 CAS 重试操作意味着长时间地占用 CPU。自旋锁重试之后如果抢锁依然失败，同步锁就会升级至重量级锁，锁标志位改为 10。在这个状态下，未抢到锁的线程都会进入 </p><p> Monitor，之后会被阻塞在 _WaitSet 队列中。</p><p><strong>重量级锁</strong></p><p>此时锁标志位为：10。前面我们提到的markWord，若是重量锁，对象头中还会存在一个监视器对象，也就是Monitor对象。这个Monitor对象就是实现synchronized的一个关键。</p><p>在Java虚拟机(HotSpot)中，Monitor对象其实就是ObjectMonitor对象，这个对象是一个C++对象，定义在虚拟机源码中。</p><p>ObjectMonitor有比较多的属性，但是比较重要的属性有四个：</p><ul><li>_count：计数器。用来记录获取锁的次数。该属性主要用来实现重入锁机制。</li><li>_owner：记录着当前锁对象的持有者线程。</li><li>_WaitSet：队列。当一个线程调用了wait方法后，它会释放锁资源，进入WaitSet队列等待被唤醒。</li><li>_EntryList：队列。里面存放着所有申请该锁对象的线程。</li></ul><p>所以一个线程获取锁对象的流程如下：</p><ol><li>判断锁对象的锁标志位是重量级锁，于是想要获取Monitor对象锁。</li><li>如果Monitor中的count属性是0，说明当前锁可用，于是把 _owner 属性设置为本线程，然后把 _count 属性+1。这就成功地完成了锁的  获取。</li><li>如果Monitor中的count属性不为0，再检查 _owner 属性，如果该属性指向了本线程，说明可以重入锁，于是把 _count 属性再加实现锁的重入。</li><li>如果 _owner 属性指向了其他线程，那么该线程进入 _EntryList 队列中等待锁资源的释放。</li><li>如果线程在持有锁的过程中调用了wait()方法，那么线程释放锁对象，然后进入 _WaitSet 队列中等待被唤醒。</li></ol><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>synchronized的执行过程： </p><ol><li>检测Mark Word里面是不是当前线程的ID，如果是，表示当前线程处于偏向锁 </li><li>如果不是，则使用CAS将当前线程的ID替换Mard Word，如果成功则表示当前线程获得偏向锁，置偏向标志位1 </li><li>如果失败，则说明发生竞争，撤销偏向锁，进而升级为轻量级锁。 </li><li>当前线程使用CAS将对象头的Mark Word替换为锁记录指针，如果成功，当前线程获得锁 </li><li>如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。 </li><li>如果自旋成功则依然处于轻量级状态。 </li><li>如果自旋失败，则升级为重量级锁。</li></ol><p>上面几种锁都是JVM自己内部实现，当我们执行synchronized同步块的时候jvm会根据启用的锁和当前线程的争用情况，决定如何执行同步操作；</p><p>在所有的锁都启用的情况下线程进入临界区时会先去获取偏向锁，如果已经存在偏向锁了，则会尝试获取轻量级锁，启用自旋锁，如果自旋也没有获取到锁，则使用重量级锁，没有获取到锁的线程阻塞挂起，直到持有锁的线程执行完同步块唤醒他们；</p><p>synchronized锁升级实际上是把本来的悲观锁变成了 在一定条件下 使用无锁(同样线程获取相同资源的偏向锁)，以及使用乐观(自旋锁 cas)和一定条件下悲观(重量级锁)的形式。</p><p>偏向锁:适用于单线程适用锁的情况，如果线程争用激烈，那么应该禁用偏向锁。</p><p>轻量级锁：适用于竞争较不激烈的情况(这和乐观锁的使用范围类似)</p><p>重量级锁：适用于竞争激烈的情况</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java基础</title>
      <link href="/2022/06/28/Java%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/06/28/Java%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="javaSE"><a href="#javaSE" class="headerlink" title="javaSE"></a>javaSE</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><table><thead><tr><th>数据类型</th><th>关键字</th><th>内存占用</th><th>范围</th></tr></thead><tbody><tr><td>字节</td><td>byte</td><td>1字节</td><td>-128~127</td></tr><tr><td>短整型</td><td>short</td><td>2字节</td><td>2^16~2^16-1</td></tr><tr><td>整型</td><td>int</td><td>4字节</td><td>2^32~2^32-1</td></tr><tr><td>长整型</td><td>long</td><td>8字节</td><td>2^64~2^64-1</td></tr><tr><td>单精度浮点</td><td>flot</td><td>4字节</td><td>-3.4E38~3.4E38</td></tr><tr><td>双精度浮点</td><td>double</td><td>8字节</td><td>-2.23E308~2.23E308</td></tr><tr><td>字符型</td><td>char</td><td>2字节</td><td>0~2^16-1</td></tr><tr><td>布尔</td><td>boolean</td><td>1字节</td><td>true，false</td></tr></tbody></table><h3 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h3><h4 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">short</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> s;<span class="comment">//隐式转换</span></span><br></pre></td></tr></table></figure><h4 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">short</span> <span class="variable">s</span> <span class="operator">=</span> (<span class="type">short</span>)i;<span class="comment">//强制类型转换</span></span><br></pre></td></tr></table></figure><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><h4 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">=、-+、+=、*=、/=</span><br></pre></td></tr></table></figure><h4 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">==,!=,&gt;,&gt;=,&lt;,&lt;=、<span class="literal">true</span>、<span class="literal">false</span></span><br></pre></td></tr></table></figure><h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&amp;逻辑与:有<span class="literal">false</span>则<span class="literal">false</span>。</span><br><span class="line">|逻辑或:有<span class="literal">true</span>则<span class="literal">true</span>。</span><br><span class="line">^逻辑异或:相同为<span class="literal">false</span>，不同为<span class="literal">true</span>。</span><br><span class="line">!逻辑非:非<span class="literal">false</span>则<span class="literal">true</span>，非<span class="literal">true</span>则<span class="literal">false</span>。</span><br><span class="line">&amp;&amp;具有短路效果:左边是<span class="literal">false</span>，右边不执行。</span><br><span class="line">||具有短路效果:左边是<span class="literal">true</span>,右边不执行</span><br></pre></td></tr></table></figure><h4 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;左移位a &lt;&lt; <span class="number">2</span>空位补<span class="number">0</span>，被移除的高位丢弃   <span class="number">1</span>&lt;&lt;<span class="number">1</span>=<span class="number">2</span>;</span><br><span class="line">&gt;&gt;右移位a &gt;&gt; <span class="number">2</span>被移位的二进制最高位为<span class="number">0</span>，右移后，空缺位补<span class="number">0</span>；最高位为<span class="number">1</span>，空缺位补<span class="number">1</span>  <span class="number">1</span>&gt;&gt;<span class="number">1</span>=<span class="number">0</span>,<span class="number">2</span>&gt;&gt;<span class="number">1</span>=<span class="number">1</span></span><br><span class="line">&gt;&gt;&gt;无符号右移位a &gt;&gt;&gt; <span class="number">2</span>被移位二进制最高位无论是<span class="number">0</span>还是<span class="number">1</span>，空缺位都用<span class="number">0</span>补 </span><br></pre></td></tr></table></figure><h4 id="三运运算符"><a href="#三运运算符" class="headerlink" title="三运运算符"></a>三运运算符</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">? a:b;<span class="number">1</span>==<span class="number">1</span> ?<span class="literal">true</span>:<span class="literal">false</span>;</span><br></pre></td></tr></table></figure><h3 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h3><table><thead><tr><th>类型</th><th>同一类</th><th>同一包</th><th>派生类</th><th>不同包</th></tr></thead><tbody><tr><td>private</td><td>能</td><td></td><td></td><td></td></tr><tr><td>default</td><td>能</td><td>能</td><td></td><td></td></tr><tr><td>protected</td><td>能</td><td>能</td><td>能</td><td></td></tr><tr><td>public</td><td>能</td><td>能</td><td>能</td><td>能</td></tr></tbody></table><h3 id="方法的重写、重载"><a href="#方法的重写、重载" class="headerlink" title="方法的重写、重载"></a>方法的重写、重载</h3><p><strong>重写 总结：</strong><br>1.发生在父类与子类之间<br>2.方法名，参数列表，返回类型（除过子类中方法的返回类型是父类中返回类型的子类）必须相同<br>3.重写方法的访问修饰符权限大于等于父类方法（public&gt;protected&gt;default&gt;private)<br>4.重写方法抛出异常小于父类抛出异常</p><p> 程序编译失败,原因分析：</p><p>1、在java多态机制中，对象引用fs在编译时期是属于父类类型也即Father类型，但是在运行时fs属于子类类型，也就是Son类型。</p><p>2、也就是说在编译的时候，编译器发现catch中的IOException完全能将父类方法中抛出的异常捕获，因此编译通过，但是在运行时期，由于fs变成了子类类型，子类重写的方法抛出的异常是Exception，显然IOException不能捕获这个比它更大的异常，因此在运行时期也就出现失败。</p><p>总结：这个示例也就演示了一个道理，在java中，子类重写父类的方法时，子类如果选择抛出异常，那么抛出的异常类型不能大于父类的异常类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">father_function</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span> &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">father_function</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;b.txt&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Father</span> <span class="variable">fs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">fs.father_function();</span><br><span class="line">&#125;<span class="keyword">catch</span> (IOException ie) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;发生了异常&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>重载 总结：</strong><br> 1.重载Overload是一个类中多态性的一种表现<br> 2.重载要求同名方法的参数列表不同(参数类型，参数个数甚至是参数顺序)<br> 3.重载的时候，返回值类型可以相同也可以不相同。无法以返回型别作为重载函数的区分标准</p><h3 id="java集合"><a href="#java集合" class="headerlink" title="java集合"></a>java集合</h3><h4 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h4><table><thead><tr><th>List接口实现类</th><th>数据结构</th><th>默认值</th><th>扩容</th><th>线程安全</th></tr></thead><tbody><tr><td>ArrayList</td><td>基于动态数组</td><td>默认10</td><td>old+(old&gt;&gt;1)</td><td>非线程安全</td></tr><tr><td>LinkedList</td><td>双向链表</td><td></td><td></td><td>非线程安全</td></tr><tr><td>Vector</td><td>数组</td><td>默认10</td><td>2倍</td><td>线程安全</td></tr></tbody></table><table><thead><tr><th>Set接口实现类</th><th>数据结构</th><th>有序性</th><th>默认值</th><th>扩容</th><th>线程安全</th></tr></thead><tbody><tr><td>HashSet</td><td>底层HashMap</td><td>无序</td><td>16</td><td>2倍</td><td>非线程安全</td></tr><tr><td>LinkedHashSet</td><td>双向链表(继承HashSet)</td><td>有序</td><td></td><td></td><td>非线程安全</td></tr><tr><td>TreeSet</td><td>二叉树（基于比较器）</td><td>有序</td><td></td><td></td><td>非线程安全</td></tr></tbody></table><h4 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h4><table><thead><tr><th>map接口实现类</th><th>数据结构</th><th>有序性</th><th>默认值</th><th>扩容</th><th>键值对为空</th><th>线程安全</th></tr></thead><tbody><tr><td>HashMap</td><td>数组+链表+红黑树</td><td>无序</td><td>16</td><td>2倍</td><td>可以</td><td>非线程安全</td></tr><tr><td>HashTable</td><td>hash表</td><td>无序</td><td>11</td><td>(old&lt;&lt;1)+1</td><td>都不可以</td><td>线程安全</td></tr><tr><td>Properties</td><td>HashTable子类</td><td></td><td>11</td><td>（size&lt;&lt;1)+1</td><td>都为String</td><td>线程安全</td></tr><tr><td>TreeMap</td><td>红黑树（基于比较器）</td><td></td><td></td><td></td><td></td><td>非线程安全</td></tr><tr><td>ConcurrentHashMap</td><td>数组+链表+红黑树</td><td>无序</td><td>16</td><td>2倍</td><td>都不可以</td><td>线程安全</td></tr></tbody></table><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><p>面向过程：考虑问题主要是分步，步骤不可逆，顺序执行。</p><p>面向对象：考虑问题主要是找到解决问题的类，用类创建对象，用对象调用属性或者方法。</p><h4 id="三大特性"><a href="#三大特性" class="headerlink" title="三大特性"></a>三大特性</h4><p><strong>封装</strong></p><p>将类的细节隐藏起来，通过private修饰符，阻止外界访问。</p><p><strong>继承</strong></p><p>子类继承父类的非私有（private）方法和属性，不能继承构造方法。</p><p>this和super关键字：</p><ol><li>this：代表本类对象的调用。super：代表对父类中的对象进行调用。</li><li>this.成员变量：访问本类成员变量。super.成员变量：访问父类成员变量。</li><li>this.成员方法：访问本类成员方法。super.成员方法：访问父类成员方法。 </li><li>this(…)：访问本类构造方法。 super(…)：访问父类构造方法。</li></ol><p><strong>多态</strong></p><p>父类引用指向子类对象。</p><p>多态实现步骤：</p><ol><li>有继承，有父子类。</li><li>父类定义方法，子类重写方法。</li><li>父类的引用，子类的对象。</li></ol><h4 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h4><table><thead><tr><th>类型</th><th>定义位置</th><th>是否可以加修饰符</th><th>访问外部类所有成员</th></tr></thead><tbody><tr><td>匿名内部类</td><td>定义在外部局部位置（：方法）</td><td>不能，可以用final修饰</td><td>可以</td></tr><tr><td>局部内部类</td><td>定义在外部局部位置（：方法）</td><td>不能，可以用final修饰</td><td>可以</td></tr><tr><td>成员内部类</td><td>定义在外部成员位置</td><td>可以添加任意修饰符</td><td>可以</td></tr><tr><td>静态内部类</td><td>定义在外部成员位置</td><td>可以添加任意修饰符</td><td>可以</td></tr></tbody></table><p>内部类作用：</p><ul><li>内部类方法可以访问该类定义所在作用域中的数据，包括被 private 修饰的私有数据。</li><li>内部类可以对同一包中的其他类隐藏起来。</li><li>内部类可以解决 java 单继承的缺陷。</li><li>当我们想要定义一个回调函数却不想写大量代码的时候我们可以选择使用匿名内部类来实现。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *匿名内部类是没有访问修饰符的。</span></span><br><span class="line"><span class="comment"> * 匿名内部类必须继承一个抽象类或者实现一个接口</span></span><br><span class="line"><span class="comment"> * 匿名内部类中不能存在任何静态成员或方法</span></span><br><span class="line"><span class="comment"> * 匿名内部类是没有构造方法的，因为它没有类名。</span></span><br><span class="line"><span class="comment"> * 与局部内部类相同匿名内部类也可以引用局部变量。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Out</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InnerNiMing</span>() &#123;<span class="comment">//匿名内部类</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">t1</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(Out.<span class="built_in">this</span>.age);</span><br><span class="line">                System.out.println(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.t1();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">InnerJuBu</span> &#123;<span class="comment">//局部内部类</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">t2</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(Out.<span class="built_in">this</span>.age);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">InnerChengYuan</span> &#123;<span class="comment">//成员内部类</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">t3</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(Out.<span class="built_in">this</span>.age);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">InnerStatic</span> &#123;<span class="comment">//静态内部类</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">t4</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InnerNiMing</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">t1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;匿名内部类!!!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="接口、抽象类"><a href="#接口、抽象类" class="headerlink" title="接口、抽象类"></a>接口、抽象类</h4><ul><li>接口只能定义变量且只能用public static final修饰（等于常量）；抽象类没有限制。</li><li>接口没有构造器，抽象类有。</li><li>接口可以继承多个接口，抽象类只能单继承。</li><li>接口中的方法只能public abstract 修饰，jdk1.8提供protected修饰；抽象类没有限制；</li><li>其实abstract class表示的是”is-a”关系（狗是一只动物）；interface表示的是”like-a”关系（鸡会飞）。</li></ul><h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Exception1</span> &#123;</span><br><span class="line">    <span class="comment">//******************以下是运行时异常***************************</span></span><br><span class="line">    <span class="comment">//ArithmeticException</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test6</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        System.out.println(a / b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//InputMismatchException</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test5</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        System.out.println(score);</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//NumberFormatException</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line">        str = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> Integer.parseInt(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ClassCastException</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> (String) obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//IndexOutOfBoundsException</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        System.out.println(str.charAt(<span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//NullPointerException</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        str = <span class="literal">null</span>;</span><br><span class="line">        System.out.println(str.charAt(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//******************以下是编译时异常***************************</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test7</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> fis.read();</span><br><span class="line">        <span class="keyword">while</span> (data != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.print((<span class="type">char</span>) data);</span><br><span class="line">            data = fis.read();</span><br><span class="line">        &#125;</span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>异常处理方式一：</strong>try-catch-finally</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">// try块监控可能出现异常的代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception ex)&#123;</span><br><span class="line">    <span class="comment">// catch块捕获异常对象，进行异常处理</span></span><br><span class="line">&#125;fianlly&#123;</span><br><span class="line">    <span class="comment">// 无论出现不出现异常，finally块一定执行，用于释放自愿</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>异常处理方式二：</strong>throws,throw</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodOne</span><span class="params">()</span><span class="keyword">throws</span> Exception&#123;<span class="comment">// throws关键字用于声明方法不处理的异常，将该类异常抛给调用点处理</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Excetpion</span>();<span class="comment">// throw关键字用于抛出手动创建的异常对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>throw 和 throws区别：</p><ul><li>throw 表示抛出一个异常类的对象，生成异常对象的过程。声明在方法体内。</li><li>throws 属于异常处理的一种方式，声明在方法的声明处。</li></ul><h4 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class  自定义异常类 extends 异常类型(Exception)&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 因为父类已经把异常信息的操作都完成了，所在子类只要在构造时，将异常信息传递给父类通过super 语句即可。</span></span><br><span class="line">  <span class="comment">// 重写 有参 和 无参  构造方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//无参构造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">CustomException</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="built_in">super</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//有参的构造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">CustomException</span><span class="params">(String message)</span>&#123;</span><br><span class="line"><span class="built_in">super</span>(message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用指定的详细信息和原因构造一个新的异常</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">CustomException</span><span class="params">(String message, Throwable cause)</span>&#123;</span><br><span class="line"><span class="built_in">super</span>(message,cause);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用指定原因构造一个新的异常</span></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">CustomException</span><span class="params">(Throwable cause)</span> &#123;</span><br><span class="line"> <span class="built_in">super</span>(cause);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//备注： 这些方法怎么来的？ 重写父类Exception的方法，那么如何查看Exception具有哪些API，快捷键：选中Exception, command+单击。windows系统 ：选中Exception, control+单击。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><h4 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h4><table><thead><tr><th>符号</th><th>表达式</th><th>说明</th></tr></thead><tbody><tr><td>？</td><td>b?</td><td>表示有0或多个b</td></tr><tr><td>+</td><td>b+</td><td>表示1或多个b</td></tr><tr><td>*</td><td>b*</td><td>表示0或多个b</td></tr><tr><td>{n}</td><td>b{4}</td><td>表示4个b</td></tr><tr><td>{n,}</td><td>b{4,}</td><td>表示大于等于4个b</td></tr><tr><td>{n,m}</td><td>b{4,6}</td><td>表示4到6个</td></tr></tbody></table><h4 id="选择匹配符"><a href="#选择匹配符" class="headerlink" title="选择匹配符"></a>选择匹配符</h4><table><thead><tr><th>符号</th><th>表达式</th><th>说明</th></tr></thead><tbody><tr><td>|</td><td>cat|dog</td><td>dog或cat</td></tr></tbody></table><h4 id="字符匹配符"><a href="#字符匹配符" class="headerlink" title="字符匹配符"></a>字符匹配符</h4><table><thead><tr><th>符号</th><th>表达式</th><th>说明</th></tr></thead><tbody><tr><td>[]</td><td>[efgn]</td><td>e、f、g、n任意一个</td></tr><tr><td>[^]</td><td>[^abc]</td><td>除a、b、c任意一个</td></tr><tr><td>-</td><td>A-Z</td><td>A到Z任意一个</td></tr><tr><td>.</td><td></td><td>除“\n”任意一个</td></tr><tr><td>\\d</td><td>\\d</td><td>相当于[0-9]</td></tr><tr><td>\\D</td><td>\\D</td><td>相当于[ ^ 0-9]</td></tr><tr><td>\\w</td><td>\\w</td><td>相当于[0-9a-zA-Z]</td></tr><tr><td>\\W</td><td>\\W</td><td>相当于[ ^ 0-9a-zA-Z]</td></tr></tbody></table><h4 id="定位符"><a href="#定位符" class="headerlink" title="定位符"></a>定位符</h4><table><thead><tr><th>符号</th><th>表达式</th><th>说明</th></tr></thead><tbody><tr><td>^</td><td>^[0-9]</td><td>以0~9任意一个开头</td></tr><tr><td>$</td><td>[0-9]$</td><td>以0~9任意一个结尾</td></tr><tr><td>\\b</td><td>er\b</td><td>边界匹配,匹配”never”中的”er”，但不匹配”verb”中的”er”</td></tr><tr><td>\\B</td><td>er\b</td><td>非边界匹配</td></tr></tbody></table><p><a href="https://blog.csdn.net/cygzsw/article/details/120135665?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165667527116780366541625%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=165667527116780366541625&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-3-120135665-null-null.142^v30^pc_search_result_control_group,185^v2^control&utm_term=%E9%9F%A9%E9%A1%BA%E5%B9%B3%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8Fjava&spm=1018.2226.3001.4187">韩顺平正则表达式</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
